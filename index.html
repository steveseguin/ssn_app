<html>
<head>
	<title>Social Stream Ninja</title>
	<meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
	<meta content="utf-8" http-equiv="encoding" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes"/>
	<meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline' 'unsafe-eval' blob:; worker-src 'self' 'unsafe-inline' 'unsafe-eval' blob:;"/>
	<link rel="stylesheet" href="https://maxst.icons8.com/vue-static/landings/line-awesome/line-awesome/1.3.0/css/line-awesome.min.css">
	<link rel="stylesheet" type="text/css" href="main.css" />
	<style>
		.session-item {
			padding: 10px 15px;
			margin: 5px 0;
			border-radius: 6px;
			cursor: pointer;
			display: flex;
			justify-content: space-between;
			align-items: center;
			background: rgba(255, 255, 255, 0.05);
			transition: all 0.2s ease;
		}
		
		.session-item:hover {
			background: rgba(255, 255, 255, 0.1);
		}
		
		.session-item.selected {
			background: rgba(76, 175, 80, 0.3);
			border: 1px solid rgba(76, 175, 80, 0.6);
		}
		
		.session-item-name {
			font-weight: 500;
		}
		
		.session-item-actions {
			display: flex;
			gap: 10px;
			align-items: center;
		}
		
		.session-remove-btn {
			background: transparent;
			border: none;
			color: #e74c3c;
			cursor: pointer;
			padding: 5px;
			font-size: 16px;
			opacity: 0.7;
			transition: opacity 0.2s;
		}
		
		.session-remove-btn:hover {
			opacity: 1;
		}
		
		.session-remove-btn:disabled {
			opacity: 0.3;
			cursor: not-allowed;
		}
	</style>
</head>
<body>
    <nav id="main-navigation">
        <button class="menu-toggle" onclick="toggleMenu()">☰</button>
        <ul>
            <li><a href="#" data-page="streams">🎭 Sources</a></li>
			<li><a href="#" data-page="dashboard">📰 Status and Logs</a></li>
            <li><a href="#" data-page="event-flow-editor">🪤 Event Flow Editor</a></li>
			<li><a href="#" data-page="vdo-ninja">🎦 Remote Camera Feed</a></li>
			<li><a href="#" data-page="sessions">🧑‍🤝‍🧑 Sessions</a></li>
            </ul>
            <div class="language-selector">
                <select id="language-select" onchange="changeLanguage(this.value)">
                    <option value="en">🇺🇸 English</option>
                    <option value="pt-BR">🇧🇷 Português (Brasil)</option>
                    <option value="es">🇪🇸 Español</option>
                    <option value="fr">🇫🇷 Français</option>
                    <option value="de">🇩🇪 Deutsch</option>
                    <option value="it">🇮🇹 Italiano</option>
                    <option value="ja">🇯🇵 日本語</option>
                    <option value="zh">🇨🇳 中文</option>
                    <option value="ko">🇰🇷 한국어</option>
                    <option value="ru">🇷🇺 Русский</option>
                    <option value="tr">🇹🇷 Türkçe</option>
                </select>
            </div>
    </nav>

    <main id="content-pane">
        <div id="streams-page">
            <div class="addnew">
                <p data-i18n="source.add">Add a new source:</p>
                <span><button onclick="newSourcePrompt('youtube');" data-source-type="youtube-username"><img src="https://socialstream.ninja/sources/images/youtube.png" class="icon"/>YouTube Username</button></span>
                <span><button onclick="newSourceVideoIDPrompt('youtube');" data-source-type="youtube-videoid"><img src="https://socialstream.ninja/sources/images/youtube.png" class="icon"/>YouTube Video ID</button></span>
                <span><button onclick="newSourcePrompt('twitch');" data-source-type="twitch"><img src="https://socialstream.ninja/sources/images/twitch.png" class="icon"/>Twitch Username</button></span>
                <span><button onclick="newSourcePrompt('kick');" data-source-type="kick"><img src="https://socialstream.ninja/sources/images/kick.png" class="icon"/>Kick Username</button></span>
                <span><button onclick="newSourcePrompt('instagramlive');" data-source-type="instagram"><img src="https://socialstream.ninja/sources/images/instagramlive.png" class="icon"/>Instagramlive Username</button></span>
                <span><button onclick="newSourcePrompt('facebook');" data-source-type="facebook"><img src="https://socialstream.ninja/sources/images/facebook.png" class="icon"/>Facebook Username</button></span>
                <span><button onclick="newSourcePrompt('tiktok');" data-source-type="tiktok"><img src="https://socialstream.ninja/sources/images/tiktok.png" class="icon"/>tiktok Username</button></span>
                <span><button onclick="newSourcePrompt('trovo');"><img src="https://socialstream.ninja/sources/images/trovo.png" class="icon"/>trovo Username</button></span>
                <span><button onclick="newSourcePrompt('picarto');"><img src="https://socialstream.ninja/sources/images/picarto.png" class="icon"/>picarto Username</button></span>
                <span><button onclick="newSourcePrompt('dlive');"><img src="https://socialstream.ninja/sources/images/dlive.png" class="icon"/>dlive Username</button></span>
                <span><button onclick="newSourcePrompt('x');"><img src="https://socialstream.ninja/sources/images/x.png" class="icon"/>X.com Username</button></span>
                <span><button onclick="newSourcePrompt('rumble');"><img src="https://socialstream.ninja/sources/images/rumble.png" class="icon"/>Rumble Username</button></span>
                <span><button onclick="newSourceVideoIDPrompt('rumble');"><img src="https://socialstream.ninja/sources/images/rumble.png" class="icon"/>Rumble Video URL</button></span>
                <span><button onclick="newSourcePrompt('beamstream');"><img src="https://socialstream.ninja/sources/images/beamstream.png" class="icon"/>Beamstream Username</button></span>
                <span><button onclick="newSourcePrompt('parti');"><img src="https://socialstream.ninja/sources/images/parti.png" class="icon"/>Parti User ID</button></span>
				<span><button onclick="newSourcePrompt('arenasocial');"><img src="https://socialstream.ninja/sources/images/arenasocial.png" class="icon"/>Arena Social Username</button></span>
                <span class="hidden"><button onclick="newSourcePrompt('pilled');"><img src="https://socialstream.ninja/sources/images/pilled.png" class="icon"/>Pilled Username</button></span>
                <span><button onclick="newSourcePrompt('bilibili');"><img src="https://socialstream.ninja/sources/images/bilibili.png" class="icon"/>BiliBili Stream ID</button></span>
                <span><button onclick="newOtherSourcePrompt('peertube');"><img src="https://socialstream.ninja/sources/images/peertube.png" class="icon"/>Peertube URL</button></span>
                <span><button title="Add a chat source that isn't listed by providing the chat URL" onclick="newOtherSourcePrompt();" data-source-type="other"><img src="https://socialstream.ninja/sources/images/unknown.png" class="icon"/>Other chat sites</button></span>
            </div>

            <div id="sources" style="right:calc(max(35%, 400px))">
                <h2 style="margin: 10px;" data-i18n="app.title">Social Stream Ninja Standalone</h2>
                <span id='newver' class='hidden'>
                    <h1 data-i18n="app.newversion">NEW VERSION AVAILABLE</h1>
                    <a id="downloadlink" data-i18n="app.download">Download new version here</a>
                </span>
                <p style="margin: 0 0 15px 10px; color: #9d8c8c;">Added Sources:</p>
            </div>
			
			<div id="link-overlay-page" style="min-width:400px;right:0;position:absolute;height:100%;width:35%">
				<iframe id="frame1" class="loading" style="height:100%;width:100%" allow="clipboard-write;document-domain;encrypted-media;sync-xhr;usb;web-share;cross-origin-isolated;accelerometer;midi *;geolocation;autoplay;camera;microphone;fullscreen;gyroscope;shared-array-buffer;" ></iframe>
			</div>
        </div>

        <div id="dashboard-page" style="display:none;">
			<iframe id="frame2" class="loading" style="height:100%;width:100%" aria-hidden="true" allow="clipboard-write;document-domain;encrypted-media;sync-xhr;usb;web-share;cross-origin-isolated;accelerometer;midi *;geolocation;autoplay;camera;microphone;fullscreen;gyroscope;shared-array-buffer;" title="Background Service Loader"></iframe>
        </div>
			
		<div id="vdo-ninja-page" style="display:none;">
			<iframe id="frame3" class="loading" style="height:100%;width:100%" allow="clipboard-write;document-domain;encrypted-media;sync-xhr;usb;web-share;cross-origin-isolated;accelerometer;midi *;geolocation;autoplay;camera;microphone;fullscreen;gyroscope;shared-array-buffer;" ></iframe>
        </div>
		
		<div id="sessions-page" style="display:none;">
			<div class="sessions-container">
				<h2 data-i18n="sessions.title">User Sessions</h2>
				<p class="sessions-info" data-i18n="sessions.info">Manage multiple user profiles with separate settings and sources.</p>
				
				<div class="current-session-info">
					<h3 data-i18n="sessions.current">Current Session</h3>
					<div class="session-display">
						<span class="session-name" id="current-session-name">Default Session</span>
						<span class="session-label" data-i18n="sessions.active">Active</span>
					</div>
				</div>
				
				<div class="sessions-list">
					<h3 data-i18n="sessions.available">Available Sessions</h3>
					<div id="sessions-list-container">
						<!-- Sessions will be populated here -->
					</div>
					<button class="new-session-btn" onclick="createNewSession()" data-i18n="sessions.create">
						➕ Create New Session
					</button>
					<div class="session-import-export">
						<button class="export-session-btn" onclick="exportCurrentSession()" data-i18n="sessions.export">
							💾 Export Current Session
						</button>
						<button class="import-session-btn" onclick="importSession()" data-i18n="sessions.import">
							📂 Import Session
						</button>
					</div>
				</div>
				
				<div class="session-warnings">
					<p>ℹ️ <strong>Note:</strong> The "Default Session (Original)" contains all your existing sources and settings.</p>
					<p>🔄 <strong>Switching:</strong> Changing sessions will restart the application.</p>
					<p>⚠️ <strong>Important:</strong> Each session has completely separate settings, sources, and stored data.</p>
				</div>
			</div>
		</div>
			
	</main>

	<div id="sourceTemplate" class="hidden entry">
		<img data-sourceicon />
		<span>
			<div>
				<span data-channelname></span>
				<span data-sourcename></span>
			</div>
			<input data-sourceurl disabled class="white hidden" />
		</span>

		<div class="control-panel">
			<div class="auto-activate-toggle">
				<div class="toggle-switch-container">
					<label class="toggle-switch">
						<input type="checkbox" data-state-key="autoActivate">
						<span class="slider"></span>
					</label>
					<span class="toggle-label">Auto-activate on startup</span>
				</div>
			</div>
		</div>

		<span class='ws-status hidden'>Websocket Activated</span>

		<div class="entry-actions-main">
			<button onclick="activateSource(this)" data-activatehtml>▶️ Activate source</button>
			<button onclick="signin(this)" title="Sign-in friendly compatible page" data-signin>🔑 Sign-in</button>
			<button onclick="showTips(this)" title="Show tips for this platform" class="hidden help-btn" data-showtips>❓ Help!</button>
		</div>

		<div class="entry-actions-live">
			<button onclick="refreshWindow(this)" title="Reload this source" data-reloadhtml class="hidden icon-button">🔄</button>
			<button onclick="toggleSourceVisibility(this)" title="Toggle the visibility of this source" data-togglehtml class="hidden icon-button">👁️</button>
			<button onclick="toggleSourceMute(this)" title="Pause/mute the video in this source" data-togglemute class="hidden icon-button">🔇</button>
			<button onclick="stopThis(this)" title="Stop and close this source" data-stophtml class="hidden icon-button">⏹️</button>
		</div>

		<button title="Additional settings for this source" class="settings-btn button">⚙️</button>
		<div class="settings-menu">
			<div class="settings-menu-section">
				<div class="settings-menu-header">Additional Controls</div>
				<div class="settings-menu-item" onclick="clearThis(this)" data-clearcache>
					🧹 Clear cache & storage
				</div>
				<div class="settings-menu-item youtube-type-toggle hidden" onclick="toggleYouTubeType(this)">
					🔄 Switch to <span class="toggle-type-text">YouTube</span>
				</div>
				<div class="settings-menu-item" onclick="openUserAgentSettings(this)">
					🌐 User Agent Settings
				</div>
				<div class="settings-menu-item" onclick="openSessionSettings(this)">
					🔐 Browser Session Settings
				</div>
				</div>
			<div class="settings-menu-section">
				<div class="settings-menu-header">Source Management</div>
				<div class="settings-menu-item danger" onclick="deleteThis(this)">
					🗑️ Remove source
				</div>
			</div>
		</div>
	</div>

    <div id="groupTemplate" class="hidden entry" data-is-group-header="true">
        <img data-sourceicon />
        <span>
            <div>
                <span data-channelname></span>
                <span data-targetname style="font-size: 0.8em; opacity: 0.7;"></span>
            </div>
        </span>
        <div class="control-panel">
             <div class="auto-activate-toggle">
				<div class="toggle-switch-container">
					<label class="toggle-switch">
						<input type="checkbox" data-state-key="autoActivate">
						<span class="slider"></span>
					</label>
					<span class="toggle-label">Auto-activate group</span>
				</div>
			</div>
        </div>
        <div class="button-group">
            <button onclick="handleYouTubeGroupActivationPrompt(this)">Select Live Sources</button>
            <button onclick="handleYouTubeGroupAutoActivation(this)">Auto-find & Activate</button>
        </div>
         <div class="group-actions">
            <button class="group-control" title="Toggle All Streams Visibility" onclick="toggleGroupVisibility(this)">👁️</button>
            <button class="group-control" title="Toggle All Streams Mute" onclick="toggleGroupMute(this)">🔊</button>
            <button class="group-control" title="Stop All Streams" onclick="stopAllStreamsInGroup(this)">⏹️</button>
            <button class="group-control" title="Reload All Streams" onclick="reloadAllStreamsInGroup(this)">🔄</button>
            <button title="Additional settings for this group" class="settings-btn button">⚙️</button>
            <div class="settings-menu">
                <div class="settings-menu-section">
					<div class="settings-menu-header">Group Management</div>
					<div class="settings-menu-item danger" onclick="deleteThis(this)">
						🗑️ Remove group & its sources
					</div>
				</div>
            </div>
        </div>
        <div class="stream-group">
            </div>
    </div>


    <div id="tipsModal" class="modal hidden">
        <div class="modal-content tips-modal-content">
            <h2 id="tipsModalTitle">Tips</h2>
            <div id="tipsModalContent"></div>
            <button class="btn-primary" onclick="closeTipsModal()">Close</button>
        </div>
    </div>

    <div class="modal hidden" id="modal">
        <div class="modal-content">
            <h2>Unknown site or site not supported</h2>
            If the URL provided is for a custom domain, please select which source type is to be used:
            <select data-type="dropdown">
                <option value="option1">Option 1</option>
                <option value="option2">Option 2</option>
                <option value="option3">Option 3</option>
                </select>
            <button data-type="submit">Select</button><button data-type="cancel">Cancel</button>
        </div>
    </div>

    <div class="yt-stream-modal" style="display:none;" id="ytStreamModal">
        <div class="yt-stream-modal-content"> 
            <span class="yt-stream-close">×</span>
            <h2>Available Live Streams</h2>
            <div class="yt-stream-list" id="ytStreamList"></div>
            <div class="yt-stream-buttons">
                <button class="yt-stream-button secondary" id="ytCancelButton">Cancel</button>
                <button class="yt-stream-button primary" id="ytActivateButton">Activate Selected</button>
            </div>
        </div>
    </div>
    
    <!-- User Agent Settings Modal -->
    <div class="modal hidden" id="userAgentModal">
        <div class="modal-content" style="max-width: 500px;">
            <h2>User Agent Settings</h2>
            <div style="margin-bottom: 20px;">
                <label for="userAgentSelect" style="display: block; margin-bottom: 8px; font-weight: bold;">Select User Agent:</label>
                <select id="userAgentSelect" style="width: 100%; padding: 8px; margin-bottom: 10px;">
                    <option value="AUTO">AUTO (Use config file)</option>
                </select>
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <input type="text" id="customUserAgentInput" placeholder="Enter custom user agent..." style="flex: 1; padding: 8px; border-radius: 4px; border: 1px solid #ccc;">
                    <button onclick="addCustomUserAgent()">Add</button>
                </div>
                <div id="customUserAgentsList" style="max-height: 200px; overflow-y: auto; margin-top: 10px; background: rgba(0,0,0,0.2); border-radius: 4px; padding: 10px;"></div>
            </div>
            <div style="display: flex; justify-content: flex-end; gap: 10px;">
                <button onclick="closeUserAgentModal()" style="background: #95a5a6;">Cancel</button>
                <button onclick="saveUserAgentSelection()">Save</button>
            </div>
        </div>
    </div>
    
    <div class="modal hidden" id="sessionModal">
        <div class="modal-content" style="max-width: 500px;">
            <h2>Browser Session Settings</h2>
            <div style="margin-bottom: 20px;">
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Select Browser Session:</label>
                    <small style="color: #ddd; display: block; margin-bottom: 10px;">Sessions allow you to be logged into different accounts on the same platform</small>
                </div>
                <div id="sessionsList" style="max-height: 300px; overflow-y: auto; background: rgba(0,0,0,0.2); border-radius: 4px; padding: 10px;">
                    <!-- Sessions will be populated here -->
                </div>
                <div style="margin-top: 15px;">
                    <label style="display: block; margin-bottom: 8px; color: #9d8c8c;">Create New Session:</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="customSessionName" placeholder="Session name (e.g., 'work-account')" style="flex: 1; padding: 8px; border-radius: 4px; border: 1px solid #ccc;">
                        <button onclick="addCustomSession()">Create</button>
                    </div>
                </div>
            </div>
            <div style="display: flex; justify-content: flex-end; gap: 10px;">
                <button onclick="closeSessionModal()" style="background: #95a5a6;">Cancel</button>
                <button onclick="saveSessionSelection()">Save</button>
            </div>
        </div>
    </div>
    
    <div class="toast-container" id="toastContainer"></div>
	
<script type="text/javascript" src="state.js"></script>
<script type="text/javascript" src="libs.js"></script>
<script type="text/javascript" src="manifest.js"></script>
<script type="text/javascript" src="thumbnail.js"></script>
<script type="text/javascript" src="youtube.js"></script>
<script>
var config = getDefaultConfig();
let configReady = false;
const storedConfig = localStorage.getItem('config');
if (storedConfig) {
	try {
		config = JSON.parse(storedConfig);
	} catch (e) {
		console.warn("Failed to parse stored config, using default.");
		config = getDefaultConfig();
	}
}

var urlParams = new URLSearchParams(window.location.search);
var devmode = urlParams.has("devmode");
var sourcemode = urlParams.get("sourcemode") || false;
// Ensure sourcemode has file:// protocol if it's a local path
if (sourcemode && !sourcemode.startsWith('http') && !sourcemode.startsWith('file://')) {
    if (sourcemode.match(/^[A-Za-z]:\//)) {
        // Windows path
        sourcemode = `file:///${sourcemode}`;
    } else if (sourcemode.startsWith('/')) {
        // Unix path
        sourcemode = `file://${sourcemode}`;
    }
}
var isBetaMode = false;
var session = {};
var ipcRenderer = null;

// Check if contextBridge exposed electron API (for windows with contextIsolation: true)
if (window.electron && window.electron.ipcRenderer) {
    console.log('[Electron] Found electron API via contextBridge');
    ipcRenderer = window.electron.ipcRenderer;
}
var localServer = "";

// Universal IPC Promise Handler
class UniversalIPCHandler {
    constructor(defaultTimeout = 15000) {
        this.callbacks = new Map();
        this.defaultTimeout = defaultTimeout;
        this.nextId = 1;
        this.maxCallbacks = 100; // Prevent unlimited growth
        this.metrics = {
            sent: 0,
            completed: 0,
            failed: 0,
            timedOut: 0
        };
        
        // Single listener for ALL IPC responses
        if (ipcRenderer) {
            ipcRenderer.on('ipc-response', (event, data) => {
                this.handleResponse(data);
            });
        }
        
        // Periodic cleanup - more aggressive
        this.cleanupInterval = setInterval(() => this.cleanup(), 10000); // Every 10 seconds
    }
    
    // Send any IPC message with optional custom timeout
    async send(channel, data, options = {}) {
        if (!ipcRenderer) {
            throw new Error('IPC not available');
        }
        
        const timeout = options.timeout || this.defaultTimeout;
        
        return new Promise((resolve, reject) => {
            // Check if we've hit the callback limit
            if (this.callbacks.size >= this.maxCallbacks) {
                // Force cleanup of oldest callbacks
                this.forceCleanup();
                
                // If still at limit, reject
                if (this.callbacks.size >= this.maxCallbacks) {
                    this.metrics.failed++;
                    reject(new Error(`IPC callback limit reached (${this.maxCallbacks}). Too many pending requests.`));
                    return;
                }
            }
            
            const callbackId = `${channel}-${this.nextId++}-${Date.now()}`;
            
            const timeoutId = setTimeout(() => {
                const callback = this.callbacks.get(callbackId);
                if (callback) {
                    this.callbacks.delete(callbackId);
                    this.metrics.timedOut++;
                    reject(new Error(`IPC timeout: ${channel} after ${timeout}ms`));
                }
            }, timeout);
            
            this.callbacks.set(callbackId, {
                resolve,
                reject,
                timeoutId,
                channel,
                timestamp: Date.now()
            });
            
            this.metrics.sent++;
            
            // Send with metadata
            ipcRenderer.send('ipc-request', {
                channel,
                callbackId,
                data,
                timestamp: Date.now()
            });
        });
    }
    
    handleResponse(response) {
        const { callbackId, error, result } = response;
        const callback = this.callbacks.get(callbackId);
        
        if (callback) {
            clearTimeout(callback.timeoutId);
            this.callbacks.delete(callbackId);
            
            if (error) {
                this.metrics.failed++;
                callback.reject(new Error(error));
            } else {
                this.metrics.completed++;
                callback.resolve(result);
            }
            
            // Log slow responses
            const duration = Date.now() - callback.timestamp;
            if (duration > 1000) {
                console.warn(`Slow IPC response for ${callback.channel}: ${duration}ms`);
            }
        }
    }
    
    // Cleanup old callbacks
    cleanup() {
        const now = Date.now();
        let cleaned = 0;
        
        this.callbacks.forEach((callback, id) => {
            if (now - callback.timestamp > 30000) { // 30 seconds (reduced from 60)
                clearTimeout(callback.timeoutId);
                callback.reject(new Error('Callback expired during cleanup'));
                this.callbacks.delete(id);
                cleaned++;
            }
        });
        
        if (cleaned > 0) {
            console.log(`IPC cleanup: removed ${cleaned} expired callbacks`);
        }
    }
    
    forceCleanup() {
        // Remove oldest callbacks until we're under 75% of limit
        const targetSize = Math.floor(this.maxCallbacks * 0.75);
        const sortedCallbacks = Array.from(this.callbacks.entries())
            .sort((a, b) => a[1].timestamp - b[1].timestamp);
        
        let cleaned = 0;
        while (this.callbacks.size > targetSize && sortedCallbacks.length > 0) {
            const [id, callback] = sortedCallbacks.shift();
            clearTimeout(callback.timeoutId);
            callback.reject(new Error('Callback forcefully cleaned due to limit'));
            this.callbacks.delete(id);
            cleaned++;
        }
        
        if (cleaned > 0) {
            console.warn(`IPC force cleanup: removed ${cleaned} callbacks to prevent memory overflow`);
        }
    }
    
    // Retry capability
    async sendWithRetry(channel, data, maxRetries = 3) {
        for (let i = 0; i < maxRetries; i++) {
            try {
                return await this.send(channel, data);
            } catch (error) {
                if (i === maxRetries - 1) throw error;
                console.log(`Retry ${i + 1}/${maxRetries} for ${channel}`);
                await new Promise(r => setTimeout(r, 1000 * (i + 1)));
            }
        }
    }
    
    // Cleanup all resources
    destroy() {
        // Clear the interval
        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
            this.cleanupInterval = null;
        }
        
        // Clear all pending callbacks
        this.callbacks.forEach((callback, id) => {
            clearTimeout(callback.timeoutId);
            callback.reject(new Error('IPC handler destroyed'));
        });
        this.callbacks.clear();
        
        console.log('IPC handler destroyed, metrics:', this.metrics);
    }
    
    // Get metrics
    getMetrics() {
        return {
            ...this.metrics,
            pending: this.callbacks.size,
            successRate: this.metrics.sent > 0 
                ? ((this.metrics.completed / this.metrics.sent) * 100).toFixed(1) + '%'
                : '0%'
        };
    }
}

// Create global instance
window.ipc = new UniversalIPCHandler();

// Function to rewrite old Kick URLs to new format
function rewriteKickUrl(url) {
    // Check if it's an old Kick chatroom URL
    const oldKickPattern = /^https:\/\/kick\.com\/([^\/]+)\/chatroom$/;
    const match = url.match(oldKickPattern);
    
    if (match) {
        // Rewrite to new format
        const username = match[1];
        const newUrl = `https://kick.com/popout/${username}/chat`;
        console.log(`Rewriting old Kick URL: ${url} -> ${newUrl}`);
        return newUrl;
    }
    
    // Return original URL if no rewriting needed
    return url;
}

// --- Core UI Update Functions ---
function updateSourceUI(element, source) {
    if (!element || !source) return;

    // Update data-target attribute
    element.dataset.target = source.target;
    
    element.querySelector("[data-sourceicon]").src = `https://socialstream.ninja/sources/images/${source.target || "unknown"}.png`;
    element.querySelector("[data-sourceicon]").title = source.target || "unknown";
    element.querySelector("[data-channelname]").textContent = source.username || "";
    element.querySelector("[data-sourcename]").textContent = source.videoId || "";
    const sourceUrlInput = element.querySelector("[data-sourceurl]");
    if (sourceUrlInput) {
        sourceUrlInput.value = source.url || "";
        sourceUrlInput.classList.toggle("hidden", !source.url);
    }
    
    if (tipsContent[source.target]) {
        element.querySelector("[data-showtips]")?.classList.remove("hidden");
    } else {
        element.querySelector("[data-showtips]")?.classList.add("hidden");
    }
    
    // Hide sign-in button when in websocket mode
    const signinButton = element.querySelector("[data-signin]");
    if (signinButton) {
        const isWebsocketMode = source.connectionMode === 'websocket' || 
                               source.connectionMode === 'tiktok-websocket';
        signinButton.classList.toggle("hidden", isWebsocketMode);
    }

    const visibilityControl = element.querySelector('[data-togglehtml]');
    if (visibilityControl) {
        visibilityControl.textContent = source.isVisible ? '👁️' : '🙈';
        // Hide for TikTok websocket mode or when not active with a window
        const isTikTokWebsocket = source.target === 'tiktok' && source.connectionMode === 'tiktok-websocket';
        visibilityControl.classList.toggle('hidden', isTikTokWebsocket || source.status !== 'active' || !source.vid);
    }
    
    const muteControl = element.querySelector('[data-togglemute]');
    if (muteControl) {
        muteControl.textContent = source.isMuted ? '🔇' : '🔊';
        muteControl.classList.toggle('active', source.isMuted);
        // Hide only for TikTok websocket mode (which doesn't support mute)
        const isTikTokWebsocket = source.target === 'tiktok' && source.connectionMode === 'tiktok-websocket';
        muteControl.classList.toggle('hidden', isTikTokWebsocket);
    }
    
    const autoActivateCheckbox = element.querySelector('.auto-activate-toggle input[data-state-key="autoActivate"]');
    if (autoActivateCheckbox) {
        autoActivateCheckbox.checked = source.autoActivate || false;
        
        // Set up the change handler if not already set
        if (!autoActivateCheckbox.hasAttribute('data-handler-set')) {
            autoActivateCheckbox.setAttribute('data-handler-set', 'true');
            autoActivateCheckbox.onchange = () => {
                stateManager.updateSource(source.id, { autoActivate: autoActivateCheckbox.checked });
                
                // Start or stop auto-checking for Rumble sources
                if (source.target === 'rumble') {
                    if (autoActivateCheckbox.checked) {
                        startRumbleAutoCheck(source.id);
                    } else {
                        stopRumbleAutoCheck(source.id);
                        // Clear video ID and chat ID when auto-activate is turned off for username-based sources
                        if (source.username && (source.videoId || source.chatId)) {
                            stateManager.updateSource(source.id, { videoId: null, chatId: null, url: null });
                        }
                    }
                }
            };
        }
    }

    const wsStatusElement = element.querySelector('.ws-status');
    if (source.connectionMode === 'websocket' || source.connectionMode === 'tiktok-websocket') {
        if (source.status === 'active' && source.wssId) {
            updateConnectionStatus(element, 'connected');
        } else if (source.status === 'inactive' && wsStatusElement && !wsStatusElement.classList.contains('error')) {
            updateConnectionStatus(element, 'clear');
        }
    } else {
         updateConnectionStatus(element, 'clear');
    }
    
    const activateButton = element.querySelector('[data-activatehtml]');
    const stopButton = element.querySelector('[data-stophtml]');
    const reloadButton = element.querySelector('[data-reloadhtml]'); 

    if (source.status === 'active' && (source.vid || source.wssId)) {
        activateButton?.classList.add('hidden');
        stopButton?.classList.remove('hidden');
        
        // Hide reload button for TikTok websocket mode
        const isTikTokWebsocket = source.target === 'tiktok' && source.connectionMode === 'tiktok-websocket';
        if (reloadButton) {
            reloadButton.classList.toggle('hidden', isTikTokWebsocket || !source.vid);
        }
        
        element.dataset.vid = source.vid; 
    } else {
        activateButton?.classList.remove('hidden');
        stopButton?.classList.add('hidden');
        reloadButton?.classList.add('hidden'); 
        delete element.dataset.vid;
    }
    updateSourceUIAfterModeChange(element, source.connectionMode, (source.status === 'active'));
    
    // Show/hide YouTube type toggle based on source type and status
    const youtubeTypeToggle = element.querySelector('.youtube-type-toggle');
    if (youtubeTypeToggle) {
        if ((source.target === 'youtube' || source.target === 'youtubeshorts') && source.status !== 'active') {
            youtubeTypeToggle.classList.remove('hidden');
            const toggleText = youtubeTypeToggle.querySelector('.toggle-type-text');
            if (toggleText) {
                toggleText.textContent = source.target === 'youtube' ? 'YouTube Shorts' : 'YouTube';
            }
        } else {
            youtubeTypeToggle.classList.add('hidden');
        }
    }
}

function updateGroupUI(element, group) {
    if (!element || !group) return;

    element.querySelector("[data-sourceicon]").src = `https://socialstream.ninja/sources/images/${group.target || "unknown"}.png`;
    element.querySelector("[data-sourceicon]").title = group.target;
    element.querySelector("[data-channelname]").textContent = group.username || "";
    element.querySelector("[data-targetname]").textContent = group.target || "";

    const autoActivateCheckbox = element.querySelector('.auto-activate-toggle input[data-state-key="autoActivate"]');
    if (autoActivateCheckbox) {
        autoActivateCheckbox.checked = group.autoActivate;
    }
    
    const visibilityButton = element.querySelector('.group-actions button[title="Toggle All Streams Visibility"]');
    if (visibilityButton) {
        visibilityButton.textContent = group.groupVisible ? '👁️' : '🙈';
    }
    const muteButton = element.querySelector('.group-actions button[title="Toggle All Streams Mute"]');
    if (muteButton) {
        muteButton.textContent = group.groupMuted ? '🔇' : '🔊';
    }
    
    // Update the connection mode in the settings menu
    const settingsMenu = element.querySelector('.settings-menu');
    if (settingsMenu) {
        settingsMenu.querySelectorAll('[data-action^="group-"]').forEach(item => {
            item.classList.remove('active');
        });
        const activeItem = settingsMenu.querySelector(`[data-action="group-${group.connectionMode || 'classic'}-mode"]`);
        if (activeItem) {
            activeItem.classList.add('active');
        }
    }
}


// --- Element Creation Functions ---
function createSourceElement(sourceId) {
    const source = stateManager.getSource(sourceId);
    if (!source) {
        console.error("createSourceElement: Source not found in stateManager for ID:", sourceId);
        return null;
    }
    
    const ele = document.getElementById("sourceTemplate").cloneNode(true);
    ele.id = `source-${sourceId}`; 
    ele.dataset.sourceId = sourceId; 
    ele.dataset.target = source.target; 
    
    ele.classList.remove("hidden");
    
    updateSourceUI(ele, source);
    setupSourceControls(ele); 
    
    // Force mode selector to be visible for sources that support it
    const modeSelector = ele.querySelector('.mode-selector');
    if (modeSelector) {
        const target = source.target;
        // Check if platform supports websockets
        const hasWebSocketSupport = 
            target.startsWith('youtube') || 
            target === 'tiktok' ||
            (manifest?.content_scripts?.some(cs => 
                cs.js?.some(jsFile => jsFile.includes(`websocket/${target}.js`))
            ) || false);
            
        if (hasWebSocketSupport) {
            modeSelector.classList.remove('hidden');
        }
    }

    return ele;
}

function createGroupElement(groupId) {
    const group = stateManager.getGroup(groupId);
    if (!group) {
        console.error("createGroupElement: Group not found in stateManager for ID:", groupId);
        return null;
    }

    const ele = document.getElementById("groupTemplate").cloneNode(true);
    ele.id = `group-${groupId}`; 
    ele.dataset.groupId = groupId; 
    ele.dataset.target = group.target; 
    ele.dataset.username = group.username; 

    ele.classList.remove("hidden");
    
    updateGroupUI(ele, group);
    setupGroupControls(ele); 

    const streamsContainer = ele.querySelector('.stream-group');
    if (streamsContainer) {
        console.log("Creating group element for:", groupId, "streams:", group.streams);
        group.streams.forEach(sourceId => {
            if (!streamsContainer.querySelector(`[data-source-id="${sourceId}"]`)) {
                console.log("Creating source element for stream:", sourceId);
                const sourceElement = createSourceElement(sourceId);
                if (sourceElement) {
                    console.log("Appending source element to group:", sourceId);
                    streamsContainer.appendChild(sourceElement);
                } else {
                    console.error("Failed to create source element for:", sourceId);
                }
            }
        });
    }
    return ele;
}

/* Modified createYouTubeEntry */
async function createYouTubeEntry(streamData, usernameForGroup, isShortSelected) {
    const target = isShortSelected ? 'youtubeshorts' : 'youtube';
    
    let group = stateManager.getGroups().find(g => g.username === usernameForGroup && g.target === target);
    let groupId = group ? group.id : null;

    if (!groupId) {
        console.warn(`Group for ${usernameForGroup} (${target}) not found. Creating now.`);
        groupId = stateManager.addGroup({ 
            target, 
            username: usernameForGroup, 
            isChannel: (usernameForGroup.startsWith('UC') || usernameForGroup.startsWith('@') ? true : false),
            autoActivate: false 
        });
        // The groupAdded listener will handle creating the group DOM element.
        // Wait for the DOM to potentially update.
        await Promise.resolve();
    }
    
    if (!groupId) {
         console.error("Cannot add YouTube entry: Failed to find or create a group ID for username:", usernameForGroup);
         return null;
    }
    const parentGroup = stateManager.getGroup(groupId);

    // Check if YouTube supports WebSockets
    let supportsWSS = false;
    if (typeof manifest !== 'undefined' && manifest?.content_scripts) {
        supportsWSS = manifest.content_scripts.some(cs => 
            cs.js?.some(jsFile => jsFile.includes(`websocket/${target}.js`))
        );
    }

    const sourceDataObject = {
        target: target,
        videoId: streamData.videoId,
        username: streamData.channelTitle || usernameForGroup,
        url: `https://www.youtube.com/live_chat?is_popout=1&v=${streamData.videoId}${isShortSelected ? '&shorts' : ''}`,
        isAutoDiscovered: true,
        groupId: groupId,
        title: streamData.title, 
        connectionMode: parentGroup?.connectionMode || 'classic',
        isVisible: parentGroup?.groupVisible !== undefined ? parentGroup.groupVisible : true,
        isMuted: parentGroup?.groupMuted !== undefined ? parentGroup.groupMuted : false,
        autoActivate: false,
        supportsWSS
    };

    const sourceId = stateManager.addSource(sourceDataObject);

    if (!sourceId) {
        console.error("Failed to add YouTube source to state manager for video ID:", streamData.videoId);
        return null;
    }
    

    // Instead of relying purely on the event listener, directly create and append if the listener hasn't already.
    // This makes it more robust for immediate activation needs.
    let sourceElement = document.querySelector(`[data-source-id="${sourceId}"]`);
    if (!sourceElement) {
        console.log(`createYouTubeEntry: Element for ${sourceId} not found by listener, creating directly.`);
        sourceElement = createSourceElement(sourceId); // This function sets up UI and controls
        if (sourceElement) {
            const groupElement = document.querySelector(`[data-group-id="${groupId}"]`);
            const streamsContainer = groupElement?.querySelector('.stream-group');
            if (streamsContainer) {
                streamsContainer.appendChild(sourceElement);
            } else if (groupElement) {
                 console.warn("createYouTubeEntry: '.stream-group' not found, appending to group header for source:", sourceId);
                 groupElement.appendChild(sourceElement);
            } else {
                console.warn("createYouTubeEntry: Group element not found, appending to main #sources for source:", sourceId);
                document.getElementById("sources").appendChild(sourceElement);
            }
        }
    }
    
    if (!sourceElement) {
        console.error(`DOM element for YouTube source ID ${sourceId} could not be created or found.`);
        return null;
    }
    
    return sourceElement; 
}


async function newSourcePrompt(target) {
    let username, isChannelName = false;
    let prompt_message = `Enter the ${target} user name`;

    if (target === "facebook") {
        prompt_message += ".\nWhen you activate this source, you'll need to still manually select the video in the page.";
        username = window.prompt(prompt_message);
    } else if (target === "youtube" || target === "youtubeshorts") {
        prompt_message = `Enter the ${target} user name or channel name`;
        prompt_message += ".\nIf loading chat via username on Youtube, you must be live and the stream set to public for it to work.";
        const response = await ipcRenderer.sendSync('prompt', {
            title: `Enter the ${target} user name or channel name`,
            message: prompt_message,
            showChannelTypeCheckbox: true,
            showShortsCheckbox: (target === "youtubeshorts")
        });
        if (response && typeof response === 'object' && 'value' in response) {
            username = response.value;
            isChannelName = response.isChannelName || false;
        } else if (response) { 
            username = response;
            isChannelName = false;
        } else {
            return;
        }
    } else if (target === "rumble") {
        prompt_message = `Enter the Rumble username or channel name`;
        const response = await ipcRenderer.sendSync('prompt', {
            title: `Enter the Rumble username or channel name`,
            message: prompt_message,
            showChannelTypeCheckbox: true
        });
        if (response && typeof response === 'object' && 'value' in response) {
            username = response.value;
            isChannelName = response.isChannelName || false;
        } else if (response) { 
            username = response;
            isChannelName = false; // Default to user if not specified
        } else {
            return;
        }
    } else if (target === "parti") {
        prompt_message = `Enter the ${target} user ID.\n\nThis is a number which can be found at the end of the pop-out chat URL.`;
        username = window.prompt(prompt_message);
    } else {
        username = window.prompt(prompt_message);
    }

    if (username) {
        await newSource(target, username.trim(), false, {}, isChannelName);
    }
}

async function newSourceVideoIDPrompt(targetPlatform) {
    let videoID, target = targetPlatform, isShorts = false;
    if (target === "youtube" || target === "youtubeshorts") {
        const response = await ipcRenderer.sendSync('prompt', {
            title: "Enter the YouTube video ID or URL",
            message: "Example: dQw4w9WgXcQ or https://youtube.com/watch?v=dQw4w9WgXcQ\nThe video must be already LIVE, and set to public or unlisted.",
            showShortsCheckbox: true
        });
        if (response && response.value) {
            const extracted = extractYoutubeID(response.value); 
            if (extracted) {
                videoID = extracted.id;
                isShorts = extracted.isShorts || response.isShorts; 
                target = isShorts ? "youtubeshorts" : "youtube";
            } else { 
                videoID = response.value;
                isShorts = response.isShorts;
                target = isShorts ? "youtubeshorts" : "youtube";
            }
        } else {
            return;
        }
    } else if (target === "rumble") {
        const input = window.prompt("Enter the Rumble video URL (e.g., https://rumble.com/a1b2c3d4-now-live.html):");
        if (input) { 
            // Check if it's a full Rumble URL and extract the video ID or full path
            const trimmedInput = input.trim();
            if (trimmedInput.includes('rumble.com/')) {
                try {
                    const url = new URL(trimmedInput);
                    const pathname = url.pathname;
                    
                    if (pathname.includes('/chat/popup/')) {
                        // Extract chat ID from popup URL
                        const chatIdMatch = pathname.match(/\/chat\/popup\/(\d+)/);
                        if (chatIdMatch && chatIdMatch[1]) {
                            videoID = chatIdMatch[1];
                        }
                    } else if (pathname.startsWith('/')) {
                        // Extract the full path (everything after the first /)
                        videoID = pathname.substring(1).replace(/\?.*$/, ''); // Remove query params
                    }
                } catch (e) {
                    // If URL parsing fails, try regex
                    const matches = trimmedInput.match(/rumble\.com\/([vp]\w+-[^?#]+)/);
                    if (matches && matches[1]) {
                        videoID = matches[1];
                    } else {
                        videoID = trimmedInput;
                    }
                }
            } else if (/^[vp]\w+$/.test(trimmedInput)) {
                // Just a video ID was entered - we can't use this alone
                alert("Please enter the full Rumble URL, not just the video ID.\n\nExample: https://rumble.com/v60552h-newsmax2-live.html");
                return;
            } else {
                videoID = trimmedInput;
            }
        } else { return; }
    } else { 
        const input = window.prompt("Enter the " + target + " video ID");
        videoID = input;
        if (!videoID) return;
    }

    if (videoID) {
       await newSourceVideoID(target, videoID.trim(), false, { isAutoDiscovered: false });
    }
}

async function cleanUpURL(url) {
	url = url.trim();
	
	// If it's already a chat popup URL, return it as-is
	if (url.startsWith("https://rumble.com/chat/popup/") || url.startsWith("http://rumble.com/chat/popup/")) {
		return url;
	}
	
	// For other Rumble URLs, try to fetch the chat ID
	if (url.startsWith("https://rumble.com/") || url.startsWith("http://rumble.com/")) {
		// Note: getRumbleVideoId actually returns the chat ID despite its name
		const chatId = await getRumbleVideoId(url);
		if (chatId) {
			return "https://rumble.com/chat/popup/" + chatId;
		}
	}
	
	return url;
}

async function newOtherSourcePrompt(target = "") {
    let URL = window.prompt("Enter the full URL for the source:");
    if (URL) {
        URL = (await cleanUpURL(URL.trim())).trim(); 
        let typeGuess = target;
        if (!typeGuess) {
            const guessedArr = checkSupported(URL); 
            if (guessedArr.length) {
                if (guessedArr.length === 1) {
                    typeGuess = guessedArr[0].split(".js")[0].split("/").pop();
                } else { 
                    try {
                        const chosenScript = await customPrompt(guessedArr.map(g => `sources/${g}`)); 
                        typeGuess = chosenScript.split(".js")[0].split("/").pop();
                    } catch (e) { Toast.error("Cancelled adding source."); return; }
                }
            } else { 
                const allSources = manifest.content_scripts.map(dom => dom.js[0].split(".js")[0].split("/").pop()).filter(Boolean);
                try {
                    const chosenScript = await customPrompt(allSources.map(s => `sources/${s}.js`));
                     typeGuess = chosenScript.split(".js")[0].split("/").pop();
                } catch (e) { 
                    Toast.error("Cancelled adding source."); 
                    return; 
                }
            }
        }
        if (typeGuess === "youtube" && (URL.includes("&shorts") || URL.includes("?shorts"))) {
            typeGuess = "youtubeshorts";
        }
        await newOtherSource(typeGuess, URL, false, {});
    }
}

/* Modified newSource */
async function newSource(target, username, startup = false, initialState = {}, isChannelName = false) {
    document.getElementById('welcomeFrame')?.remove();
    
     if (username) {
        let isUrl = false;
        try { new URL(username); isUrl = true; } catch (_) {}

        if (isUrl) {
            const url = new URL(username);
            const hostname = url.hostname.toLowerCase();
            if (hostname.includes('youtube.com') || hostname.includes('youtu.be')) {
                const result = parseYoutubeUrl(url); 
                if (result.isYoutubeUrl && result.id) {
                    return newSourceVideoID(result.isShort ? "youtubeshorts" : "youtube", result.id, startup, initialState);
                } else if (result.isYoutubeUrl && result.username) {
                    target = result.isShort ? "youtubeshorts" : "youtube"; 
                    username = result.username;
                } else { 
                    username = url.pathname.split('/').filter(Boolean)[0]; 
                }
            } 
            else if (hostname.includes('rumble.com')) {
                 if (url.pathname.startsWith("/c/")) {
                    // Extract channel name from /c/channelname/livestreams
                    const pathParts = url.pathname.split('/').filter(Boolean);
                    if (pathParts.length >= 2) {
                        username = pathParts[1]; // Get channel name
                        target = 'rumble';
                        isChannelName = true; // This is a channel URL
                    }
                } else if (url.pathname.startsWith("/user/")) {
                    // Extract username from /user/username/livestreams
                    const pathParts = url.pathname.split('/').filter(Boolean);
                    if (pathParts.length >= 2) {
                        username = pathParts[1]; // Get username
                        target = 'rumble';
                        isChannelName = false; // This is a user URL
                    }
                } else if (url.pathname.startsWith("/chat/popup/")) {
                    // Direct chat popup URL - extract chat ID
                    const chatIdMatch = url.pathname.match(/\/chat\/popup\/(\d+)/);
                    if (chatIdMatch && chatIdMatch[1]) {
                        // For chat popup URLs, use newOtherSource instead
                        return newOtherSource('rumble', url.toString(), startup, initialState);
                    }
                } else {
                    // Try to extract video ID from URL like /v6vpthn-...
                    const videoIdMatch = url.pathname.match(/^\/([vp]\w+)-/);
                    if (videoIdMatch && videoIdMatch[1]) {
                        return newSourceVideoID('rumble', videoIdMatch[1], startup, initialState);
                    } else {
                        // Fall back to fetching video ID from page
                        const videoId = await getRumbleVideoId(url.toString()); 
                        if (videoId) return newSourceVideoID('rumble', videoId, startup, initialState);
                    }
                }
            }
        }
    }


    if (!username) { 
        console.warn("newSource called without username after prompt phase.");
        return;
    }

    let elementToReturnId; 

    if (target === "youtube" || target === "youtubeshorts") {
        const groupId = stateManager.addGroup({
            target,
            username,
            isChannel: isChannelName, 
            connectionMode: initialState.connectionMode || 'classic',
            autoActivate: initialState.togglelock === "true" || initialState.autoActivate === true,
            groupVisible: initialState.groupVisible !== "false", 
            groupMuted: initialState.groupMuted === "true"
        });
        elementToReturnId = groupId; 
    } else {
        let sourceUrl = initialState.URL || initialState.url || ""; 
        let sourceFile = initialState.sourceFile || null; // Check for existing sourceFile

        if (!sourceUrl) { 
            if (target === "twitch") sourceUrl = `https://www.twitch.tv/popout/${username}/chat?popout=`;
            else if (target === "kick") sourceUrl = `https://kick.com/popout/${username}/chat`;
            else if (target === "parti") sourceUrl = `https://parti.com/popout-chat?id=${username}`;
            else if (target === "rumble") {
                if (isChannelName) {
                    sourceUrl = `https://rumble.com/c/${username}/livestreams`;
                } else {
                    sourceUrl = `https://rumble.com/user/${username}/livestreams`;
                }
            } 
            else if (target === "tiktok") sourceUrl = `https://www.tiktok.com/@${username.replace('@','')}/live`;
            else if (target === "trovo") sourceUrl = `https://trovo.live/chat/${username}`;
            else if (target === "instagram" || target === "instagramlive") sourceUrl = `https://www.instagram.com/${username}/live/`;
            else if (target === "picarto") sourceUrl = `https://picarto.tv/chatpopout/${username}/public`;
            else if (target === "dlive") sourceUrl = `https://dlive.tv/c/${username}/${username}`;
            else if (target === "x") sourceUrl = `https://x.com/${username}/chat`;
            else if (target === "beamstream") sourceUrl = `https://beamstream.gg/${username}/chat`;
            else if (target === "vimm") sourceUrl = `https://www.vimm.tv/c/${username}`;
            else if (target === "bilibili") sourceUrl = `https://live.bilibili.com/${username}`;
            else if (target === "facebook") sourceUrl = `https://www.facebook.com/${username}/videos`;
			else if (target === "arenasocial") sourceUrl = `https://arena.social/live/${username}`;
            // Add other URL constructions as needed
        }
        
        // Determine specific sourceFile if not provided in initialState
        if (!sourceFile) {
            if (target === "instagramlive" || target === "instagram") sourceFile = "sources/instagram.js";
            else if (target === "trovo") sourceFile = "sources/trovo.js";
            else if (target === "picarto") sourceFile = "sources/picarto.js";
            else if (target === "dlive") sourceFile = "sources/dlive.js";
            else if (target === "x") sourceFile = "sources/x.js";
            else if (target === "beamstream") sourceFile = "sources/beamstream.js";
            // Add other platform-specific script files here if necessary
        }


        // Check if platform supports WebSockets
        let supportsWSS = false;
        if (target === 'tiktok') {
            supportsWSS = true; // TikTok has built-in websocket support
        } else if (typeof manifest !== 'undefined' && manifest?.content_scripts) {
            supportsWSS = manifest.content_scripts.some(cs => 
                cs.js?.some(jsFile => jsFile.includes(`websocket/${target}.js`))
            );
        }
        
        // Set default connection mode based on platform
        let defaultMode = 'classic';
        // TikTok defaults to websocket mode
        if (target === 'tiktok') {
            defaultMode = 'tiktok-websocket';
        }
        
        // Force classic mode for platforms that don't have websocket support
        let connectionMode = initialState.connectionMode || defaultMode;
        if (!supportsWSS && connectionMode === 'websocket') {
            connectionMode = 'classic';
        }

        const sourceData = {
            target,
            username,
            url: sourceUrl,
            videoId: initialState.videoId || '', 
            connectionMode: connectionMode, // Use the validated connectionMode
            isVisible: initialState.togglehtml !== "false" && initialState.isVisible !== false,
            isMuted: initialState.togglemute === "true" || initialState.isMuted === true,
            autoActivate: initialState.togglelock === "true" || initialState.autoActivate === true,
            supportsWSS,
            isChannel: target === 'rumble' ? isChannelName : undefined,
            ...initialState
        };
        if (sourceFile) { // Add sourceFile to the data if it was determined
            sourceData.sourceFile = sourceFile;
        }

        const sourceId = stateManager.addSource(sourceData);
        elementToReturnId = sourceId; 
    }
    
    manageWelcomePage();
    
    await Promise.resolve(); 
    const elementToReturn = elementToReturnId ? 
        (document.querySelector(`[data-source-id="${elementToReturnId}"]`) || document.querySelector(`[data-group-id="${elementToReturnId}"]`))
        : null;

    if (elementToReturn && startup && (initialState.togglelock === "true" || initialState.autoActivate)) {
        if (elementToReturn.dataset.sourceId) { 
            const source = stateManager.getSource(elementToReturn.dataset.sourceId);
            if (source && source.autoActivate && !source.vid && !source.wssId) {
                 setTimeout(async () => {
                    const activateButton = elementToReturn.querySelector('[data-activatehtml]');
                    if (activateButton && !stateManager.getSource(source.id)?.vid && !stateManager.getSource(source.id)?.wssId) { 
                        await createWindow(activateButton);
                    }
                }, 2000 + Math.random() * 1000);
            }
        } else if (elementToReturn.dataset.groupId) { 
            const group = stateManager.getGroup(elementToReturn.dataset.groupId);
            if (group && group.autoActivate && (group.target === "youtube" || group.target === "youtubeshorts")) {
                 setTimeout(async () => {
                    console.log('Auto-activating YouTube group from newSource:', group.username);
                     await handleYouTubeActivation(
                        group.username,
                        group.target === "youtubeshorts",
                        false, 
                        true,  
                        group.isChannel
                    );
                }, 2500 + Math.random() * 1000);
            }
        }
    }
    return elementToReturn;
}

async function newSourceVideoID(target, videoID, startup = false, initialState = {}) {
    document.getElementById('welcomeFrame')?.remove();
    
    if (!videoID) return;

    let url = initialState.URL || initialState.url || "";
    if (!url) { 
        if (target === "youtube" || target === "youtubeshorts") {
            url = `https://www.youtube.com/live_chat?is_popout=1&v=${videoID}${target === "youtubeshorts" ? "&shorts" : ""}`;
        } else if (target === "rumble") {
            // For Rumble, videoID might be alphanumeric (v6vpthn) or numeric (412388813)
            // We'll fetch the proper chat ID later during activation
            url = null; // Don't set a default URL, let activation handle it
        }
    }

    // Check if platform supports WebSockets
    let supportsWSS = false;
    if (target === 'tiktok') {
        supportsWSS = true; // TikTok has built-in websocket support
    } else if (typeof manifest !== 'undefined' && manifest?.content_scripts) {
        supportsWSS = manifest.content_scripts.some(cs => 
            cs.js?.some(jsFile => jsFile.includes(`websocket/${target}.js`))
        );
    }
    
    // Set default connection mode based on platform
    let defaultMode = 'classic';
    // TikTok defaults to classic/standard mode since WebSocket is read-only

    const sourceId = stateManager.addSource({
        target,
        videoId: videoID,
        url: url,
        username: initialState.username || '', 
        connectionMode: initialState.connectionMode || defaultMode,
        isVisible: initialState.togglehtml !== "false" && initialState.isVisible !== false,
        isMuted: initialState.togglemute === "true" || initialState.isMuted === true,
        autoActivate: initialState.togglelock === "true" || initialState.autoActivate === true,
        supportsWSS,
         ...initialState
    });
    
    manageWelcomePage();
    
    await Promise.resolve(); 
    const sourceElement = document.querySelector(`[data-source-id="${sourceId}"]`);

    if (sourceElement && startup && (initialState.togglelock === "true" || initialState.autoActivate)) {
        const source = stateManager.getSource(sourceId);
         if (source && source.autoActivate && !source.vid && !source.wssId) {
            setTimeout(async () => {
                const activateButton = sourceElement.querySelector('[data-activatehtml]');
                if (activateButton && !stateManager.getSource(source.id)?.vid && !stateManager.getSource(source.id)?.wssId) {
                    await createWindow(activateButton);
                }
            }, 2000 + Math.random() * 1000);
        }
    }
    return sourceElement;
}

/* Modified newOtherSource */
async function newOtherSource(target, URL, startup = false, initialState = {}) {
    document.getElementById('welcomeFrame')?.remove();
    if (!URL) return;

    let displayName = initialState.username || '';
    let chatId = null;
    
    // Check if this is a Rumble chat popup URL
    if (URL.includes('rumble.com/chat/popup/')) {
        const chatIdMatch = URL.match(/\/chat\/popup\/(\d+)/);
        if (chatIdMatch && chatIdMatch[1]) {
            chatId = chatIdMatch[1];
            displayName = `Rumble Chat ${chatId}`;
        }
    }
    
    if (!displayName) {
        try {
            const link = new URL(URL);
            const parts = link.hostname.split('.');
            displayName = parts.length >= 2 ? `${parts[parts.length - 2]}.${parts[parts.length - 1]}` : link.hostname;
        } catch {
            displayName = target || 'Unknown Source';
        }
    }
    
    // Determine sourceFile based on target, similar to how newSource handles it
    let sourceFile = initialState.sourceFile || null;
    if (!sourceFile && target) {
        // Example: if target is 'instagramlive', sourceFile should be 'sources/instagram.js'
        // This logic needs to be robust based on your platform-to-script mapping
        if (target === "instagramlive") {
            sourceFile = "sources/instagram.js";
        } else {
            // Default assumption: target maps directly to script name
            sourceFile = `sources/${target}.js`;
        }
    }


    // Check if platform supports WebSockets
    let supportsWSS = false;
    if (target === 'tiktok') {
        supportsWSS = true; // TikTok has built-in websocket support
    } else if (target && typeof manifest !== 'undefined' && manifest?.content_scripts) {
        supportsWSS = manifest.content_scripts.some(cs => 
            cs.js?.some(jsFile => jsFile.includes(`websocket/${target}.js`))
        );
    }
    
    // Set default connection mode based on platform
    let defaultMode = 'classic';
    // TikTok defaults to classic/standard mode since WebSocket is read-only

    const sourceData = {
        target: target || 'unknown', 
        url: URL,
        username: displayName, 
        videoId: initialState.videoId || '', 
        connectionMode: initialState.connectionMode || defaultMode,
        isVisible: initialState.togglehtml !== "false" && initialState.isVisible !== false,
        isMuted: initialState.togglemute === "true" || initialState.isMuted === true,
        autoActivate: initialState.togglelock === "true" || initialState.autoActivate === true,
        supportsWSS,
        ...initialState
    };
    
    // Add chatId if this is a Rumble chat popup
    if (chatId) {
        sourceData.chatId = chatId;
        // Clear username to prevent fetching videos for "rumble"
        if (target === 'rumble') {
            sourceData.username = displayName; // Keep the display name but it won't be used for fetching
            sourceData.videoId = ''; // Ensure videoId is empty
        }
    }
    
    // For Rumble URLs that aren't standard patterns, mark them as direct URLs
    if (target === 'rumble' && URL.includes('rumble.com') && !chatId) {
        // This is a custom Rumble URL that should be used as-is
        sourceData.isDirectUrl = true;
        // Keep the URL but clear fields that would trigger fetching
        sourceData.videoId = '';
        // Keep username for display but it won't be used for fetching
    }
    if (sourceFile) {
        sourceData.sourceFile = sourceFile;
    }
    
    const sourceId = stateManager.addSource(sourceData);

    manageWelcomePage();

    await Promise.resolve(); 
    const sourceElement = document.querySelector(`[data-source-id="${sourceId}"]`);

     if (sourceElement && startup && (initialState.togglelock === "true" || initialState.autoActivate)) {
        const source = stateManager.getSource(sourceId);
         if (source && source.autoActivate && !source.vid && !source.wssId) {
            setTimeout(async () => {
                const activateButton = sourceElement.querySelector('[data-activatehtml]');
                if (activateButton && !stateManager.getSource(source.id)?.vid && !stateManager.getSource(source.id)?.wssId) {
                    await createWindow(activateButton);
                }
            }, 2000 + Math.random() * 1000);
        }
    }
    return sourceElement;
}


async function newSourceOLD(target, username = false, startup = false, state = {}, isChannelName = false) {
    console.warn("newSourceOLD is deprecated and should not be called directly. Use newSourcePrompt or newSource.");
    if (username) {
        return newSource(target, username, startup, state, isChannelName);
    }
    return null;
}

async function cleanupYouTubeGroups() {
    console.log("Cleaning up YouTube video sources on startup...");
    
    // Get ALL sources, not just auto-discovered ones
    const allSources = stateManager.getSources();
    let removedCount = 0;
    let debugInfo = {
        totalSources: allSources.length,
        youtubeSources: 0,
        withVideoId: 0,
        autoDiscovered: 0,
        removed: 0
    };
    
    allSources.forEach(source => {
        if (source.target && source.target.startsWith('youtube')) {
            debugInfo.youtubeSources++;
            
            if (source.videoId) {
                debugInfo.withVideoId++;
                
                // Debug log for each YouTube source with video ID
                console.log(`YouTube source ${source.id}: videoId=${source.videoId}, isAutoDiscovered=${source.isAutoDiscovered}, groupId=${source.groupId || 'none'}`);
                
                if (source.isAutoDiscovered === true) {
                    debugInfo.autoDiscovered++;
                    
                    // Remove auto-discovered YouTube sources that have a video ID
                    // These are expired streams that won't work anymore
                    console.log("Removing auto-discovered YouTube video source:", source.id, "videoId:", source.videoId, "username:", source.username || "none");
                    
                    // Remove the source element from DOM if it exists
                    const sourceElement = document.querySelector(`[data-source-id="${source.id}"]`);
                    if (sourceElement) {
                        sourceElement.remove();
                    }
                    
                    // Remove from state
                    stateManager.removeSource(source.id);
                    removedCount++;
                    debugInfo.removed++;
                } else if ((source.isAutoDiscovered === undefined || source.isAutoDiscovered === null) && source.groupId) {
                    // This might be a source that was auto-discovered but lost its flag during migration
                    console.warn(`YouTube source ${source.id} with videoId=${source.videoId} has undefined/null isAutoDiscovered flag but belongs to group ${source.groupId}`);
                    
                    // For backward compatibility: if a YouTube source has a videoId and belongs to a group,
                    // and doesn't have an explicit isAutoDiscovered=false flag, it's likely auto-discovered
                    // (manually added sources are explicitly marked with isAutoDiscovered=false)
                    console.log("Treating as likely auto-discovered and removing:", source.id);
                    
                    // Remove the source element from DOM if it exists
                    const sourceElement = document.querySelector(`[data-source-id="${source.id}"]`);
                    if (sourceElement) {
                        sourceElement.remove();
                    }
                    
                    // Remove from state
                    stateManager.removeSource(source.id);
                    removedCount++;
                    debugInfo.removed++;
                } else if (source.isAutoDiscovered === false) {
                    console.log(`Preserving manually added YouTube source ${source.id}: videoId=${source.videoId}`);
                }
            }
        }
    });
    
    console.log("YouTube cleanup debug info:", debugInfo);
    
    if (removedCount > 0) {
        console.log(`Removed ${removedCount} auto-discovered YouTube video sources on startup`);
        
        // Clean up orphaned stream references in groups
        const groups = stateManager.getGroups();
        groups.forEach(group => {
            if ((group.target === "youtube" || group.target === "youtubeshorts") && group.streams) {
                const validStreams = group.streams.filter(streamId => 
                    stateManager.getSource(streamId) !== null
                );
                
                if (validStreams.length !== group.streams.length) {
                    console.log(`Cleaned ${group.streams.length - validStreams.length} orphaned streams from group ${group.username}`);
                    group.streams = validStreams;
                }
            }
        });
        
        // Persist the cleaned state
        stateManager.persist();
    }
}

function setupGroupControls(groupHeaderElement) {
    if (!groupHeaderElement) return;
    const groupId = groupHeaderElement.dataset.groupId;
    if (!groupId) return;

    const group = stateManager.getGroup(groupId);
    if (!group) return;

    const target = group.target;
    const controlPanel = groupHeaderElement.querySelector('.control-panel');
    
    // Add connection mode selector for YouTube groups
    if (target && target.startsWith('youtube') && controlPanel) {
        let modeSelector = controlPanel.querySelector('.mode-selector');
        
        if (!modeSelector) {
            modeSelector = document.createElement('div');
            modeSelector.className = 'mode-selector';
            modeSelector.innerHTML = `
                <div class="mode-selector-label">Default Mode:</div>
                <div class="mode-options">
                    <div class="mode-option" 
                         data-mode="classic" 
                         onclick="setGroupConnectionMode(this.closest('.entry'), 'classic'); updateModeSelector(this)">
                        📄 Standard
                    </div>
                    <div class="mode-option" 
                         data-mode="websocket" 
                         onclick="setGroupConnectionMode(this.closest('.entry'), 'websocket'); updateModeSelector(this)">
                        🌐 WebSocket
                    </div>
                </div>
                <div class="mode-info">
                    <span class="info-icon" title="WebSocket mode uses less resources and provides additional data like followers/subs when signed in. Requires login for full features.">ℹ️</span>
                </div>`;
            
            controlPanel.appendChild(modeSelector);
            
            // Update the active state based on current connection mode
            const currentMode = group.connectionMode || 'classic';
            modeSelector.querySelectorAll('.mode-option').forEach(opt => {
                opt.classList.remove('active');
                if (opt.dataset.mode === currentMode) {
                    opt.classList.add('active');
                }
            });
        }
    }

    const autoActivateCheckbox = groupHeaderElement.querySelector('.auto-activate-toggle input[data-state-key="autoActivate"]');
    if (autoActivateCheckbox) {
        autoActivateCheckbox.checked = group.autoActivate;
        autoActivateCheckbox.onchange = () => {
            stateManager.updateGroup(groupId, { autoActivate: autoActivateCheckbox.checked });
            
            // Start or stop auto-checking for YouTube groups
            if (group.target === "youtube" || group.target === "youtubeshorts") {
                if (autoActivateCheckbox.checked) {
                    startYouTubeGroupAutoCheck(groupId);
                } else {
                    stopYouTubeGroupAutoCheck(groupId);
                }
            }
        };
    }
    
    const settingsBtn = groupHeaderElement.querySelector('.settings-btn');
    const settingsMenu = groupHeaderElement.querySelector('.settings-menu');
    if (settingsBtn && settingsMenu) {
        settingsBtn.onclick = (e) => {
            e.stopPropagation();
            document.querySelectorAll('.settings-menu.active').forEach(menu => {
                if (menu !== settingsMenu) menu.classList.remove('active');
            });
            settingsMenu.classList.toggle('active');
        };
        document.addEventListener('click', (e) => {
            if (!settingsMenu.classList.contains('hidden') && !settingsMenu.contains(e.target) && !settingsBtn.contains(e.target)) {
                settingsMenu.classList.remove('active');
            }
        });
    }
}

function toggleGroupVisibility(buttonElement) {
    const groupElement = buttonElement.closest('[data-is-group-header="true"]');
    const groupId = groupElement?.dataset.groupId;
    if (!groupId) return;
    const group = stateManager.getGroup(groupId);
    if (!group) return;
    stateManager.updateGroup(groupId, { groupVisible: !group.groupVisible });
}

function toggleGroupMute(buttonElement) {
    const groupElement = buttonElement.closest('[data-is-group-header="true"]');
    const groupId = groupElement?.dataset.groupId;
    if (!groupId) return;
    const group = stateManager.getGroup(groupId);
    if (!group) return;
    stateManager.updateGroup(groupId, { groupMuted: !group.groupMuted });
}

function updateModeSelector(clickedOption) {
    const modeOptions = clickedOption.parentElement;
    modeOptions.querySelectorAll('.mode-option').forEach(opt => {
        opt.classList.remove('active');
    });
    clickedOption.classList.add('active');
}

function setGroupConnectionMode(groupElement, mode) {
    const groupId = groupElement?.dataset.groupId;
    if (!groupId) return;
    
    const group = stateManager.getGroup(groupId);
    if (!group) return;
    
    // Update the group's connection mode
    stateManager.updateGroup(groupId, { connectionMode: mode });
    
    // Update all child sources to use the new mode
    const sources = stateManager.getSourcesByGroup(groupId);
    sources.forEach(source => {
        stateManager.updateSource(source.id, { connectionMode: mode });
        
        // Update the UI for each source
        const sourceElement = document.querySelector(`[data-source-id="${source.id}"]`);
        if (sourceElement) {
            updateSourceUIAfterModeChange(sourceElement, mode, source.status === 'active');
        }
    });
    
    // Update the group's settings menu to show the active mode
    const settingsMenu = groupElement.querySelector('.settings-menu');
    if (settingsMenu) {
        settingsMenu.querySelectorAll('[data-action^="group-"]').forEach(item => {
            item.classList.remove('active');
        });
        const activeItem = settingsMenu.querySelector(`[data-action="group-${mode}-mode"]`);
        if (activeItem) {
            activeItem.classList.add('active');
        }
    }
    
    // Close the settings menu
    const settingsBtn = groupElement.querySelector('.settings-btn');
    if (settingsBtn) {
        settingsBtn.classList.remove('active');
    }
    
    Toast.info("Connection Mode Updated", `All streams in ${group.username} are now using ${mode === 'websocket' ? 'WebSocket' : 'Standard'} mode`);
}

function stopAllStreamsInGroup(buttonElement) {
    const groupElement = buttonElement.closest('[data-is-group-header="true"]');
    const groupId = groupElement?.dataset.groupId;
    if (!groupId) return;
    const group = stateManager.getGroup(groupId);
    if (!group) return;
    group.streams.forEach(sourceId => {
        const source = stateManager.getSource(sourceId);
        if (source && (source.vid || source.wssId)) {
            const sourceElement = document.querySelector(`[data-source-id="${sourceId}"]`);
            const stopButton = sourceElement?.querySelector('[data-stophtml]');
            if (stopButton) stopThis(stopButton); 
        }
    });
}

function reloadAllStreamsInGroup(buttonElement) {
    const groupElement = buttonElement.closest('[data-is-group-header="true"]');
    const groupId = groupElement?.dataset.groupId;
    if (!groupId) return;
    const group = stateManager.getGroup(groupId);
    if (!group) return;

    group.streams.forEach(sourceId => {
        const source = stateManager.getSource(sourceId);
        if (source && source.vid) { 
            const sourceElement = document.querySelector(`[data-source-id="${sourceId}"]`);
            const reloadButton = sourceElement?.querySelector('[data-reloadhtml]');
            if (reloadButton) refreshWindow(reloadButton);
        }
    });
}

function handleYouTubeGroupActivationPrompt(buttonElement) {
    const groupElement = buttonElement.closest('[data-is-group-header="true"]');
    const groupId = groupElement?.dataset.groupId;
    if (!groupId) return;
    const group = stateManager.getGroup(groupId);
    if (!group || (group.target !== "youtube" && group.target !== "youtubeshorts")) return;

    handleYouTubeActivation(group.username, group.target === "youtubeshorts", true, false, group.isChannel);
}

function handleYouTubeGroupAutoActivation(buttonElement) {
    const groupElement = buttonElement.closest('[data-is-group-header="true"]');
    const groupId = groupElement?.dataset.groupId;
    if (!groupId) return;
    const group = stateManager.getGroup(groupId);
    if (!group || (group.target !== "youtube" && group.target !== "youtubeshorts")) return;
    
    handleYouTubeActivation(group.username, group.target === "youtubeshorts", false, true, group.isChannel);
}

// Store interval IDs for YouTube group checking
const youtubeGroupIntervals = new Map();

// Store backoff state for YouTube groups
const youtubeGroupBackoffState = new Map();

// Store interval IDs for Rumble auto-checking
const rumbleIntervals = new Map();

function startYouTubeGroupAutoCheck(groupId) {
    // Clear any existing interval for this group
    stopYouTubeGroupAutoCheck(groupId);
    
    const group = stateManager.getGroup(groupId);
    if (!group || !group.autoActivate) return;
    
    console.log(`Starting auto-check for YouTube group: ${group.username}`);
    
    // Initialize backoff state
    youtubeGroupBackoffState.set(groupId, {
        checkCount: 0,
        intervals: [60000, 360000, 960000] // 1 min, 6 min, 16 min
    });
    
    // Check immediately
    checkYouTubeGroupForNewStreamsWithBackoff(groupId);
}

function stopYouTubeGroupAutoCheck(groupId) {
    const timeoutId = youtubeGroupIntervals.get(groupId);
    if (timeoutId) {
        clearTimeout(timeoutId);
        youtubeGroupIntervals.delete(groupId);
        youtubeGroupBackoffState.delete(groupId);
        console.log(`Stopped auto-check for YouTube group: ${groupId}`);
    }
}

async function checkYouTubeGroupForNewStreamsWithBackoff(groupId) {
    // Check for new streams
    const foundNewStreams = await checkYouTubeGroupForNewStreams(groupId);
    
    // If we found NEW streams, stop checking (not just any streams)
    if (foundNewStreams) {
        stopYouTubeGroupAutoCheck(groupId);
        return;
    }
    
    // Get backoff state
    const backoffState = youtubeGroupBackoffState.get(groupId);
    if (!backoffState) return;
    
    // Determine next check interval
    let nextInterval;
    if (backoffState.checkCount < backoffState.intervals.length) {
        nextInterval = backoffState.intervals[backoffState.checkCount];
        backoffState.checkCount++;
    } else {
        // Use the last interval (16 minutes) for all subsequent checks
        nextInterval = backoffState.intervals[backoffState.intervals.length - 1];
    }
    
    const group = stateManager.getGroup(groupId);
    if (group) {
        const minutes = Math.floor(nextInterval / 60000);
        console.log(`No live streams found for YouTube group ${group.username}, checking again in ${minutes} minute(s)`);
    }
    
    // Schedule next check
    const timeoutId = setTimeout(() => {
        checkYouTubeGroupForNewStreamsWithBackoff(groupId);
    }, nextInterval);
    
    youtubeGroupIntervals.set(groupId, timeoutId);
}

async function checkYouTubeGroupForNewStreams(groupId) {
    const group = stateManager.getGroup(groupId);
    if (!group || (group.target !== "youtube" && group.target !== "youtubeshorts")) return false;
    
    console.log(`Checking for new streams in YouTube group: ${group.username}`);
    
    let streams = [];
    let usingFallback = false;
    
    try {
        // Try the API first
        const response = await fetch(`https://api.socialstream.ninja/youtube/streams?username=${encodeURIComponent(group.username)}`);
        const data = await response.json();
        
        if (!data.success || !Array.isArray(data.data)) {
            console.warn("API response invalid, falling back to fetchYoutube");
            throw new Error("Invalid API response");
        }
        
        streams = data.data;
    } catch (error) {
        console.error("API call failed, attempting fallback to fetchYoutube:", error);
        
        // Fallback to fetchYoutube
        try {
            usingFallback = true;
            
            // Check if fetchYoutube is available
            if (typeof fetchYoutube !== 'function') {
                console.error("fetchYoutube function not available");
                return false;
            }
            
            // Try both alt=false and alt=true if needed
            let fetchResult = await fetchYoutube(group.username, false);
            if (!fetchResult || fetchResult.length === 0) {
                fetchResult = await fetchYoutube(group.username, true);
            }
            
            if (fetchResult && Array.isArray(fetchResult)) {
                streams = fetchResult;
                console.log(`Fallback successful, found ${streams.length} streams via fetchYoutube`);
            } else {
                console.error("Fallback to fetchYoutube also failed");
                return false;
            }
        } catch (fallbackError) {
            console.error("Fallback to fetchYoutube failed:", fallbackError);
            return false;
        }
    }
    
    // Filter streams based on type
    const isShorts = group.target === "youtubeshorts";
    const filteredStreams = streams.filter(stream => stream.isShort === isShorts);
    
    // Get existing video IDs for this group
    const existingVideoIds = new Set();
    group.streams.forEach(sourceId => {
        const source = stateManager.getSource(sourceId);
        if (source && source.videoId) {
            existingVideoIds.add(source.videoId);
        }
    });
    
    // Find new streams
    const newStreams = filteredStreams.filter(stream => !existingVideoIds.has(stream.videoId));
    
    if (newStreams.length > 0) {
        console.log(`Found ${newStreams.length} new streams for group ${group.username}${usingFallback ? ' (via fallback)' : ''}`);
        Toast.info("New Streams Found", `Found ${newStreams.length} new live stream(s) for ${group.username}`);
        
        // Auto-activate new streams if auto-activate is enabled
        for (const stream of newStreams) {
            const newSource = {
                target: group.target,
                username: group.username,
                url: `https://www.youtube.com/live_chat?is_popout=1&v=${stream.videoId}${group.target === 'youtubeshorts' ? '&shorts' : ''}`,
                groupId: groupId,
                videoId: stream.videoId,
                title: stream.title,
                autoActivate: true // Inherit auto-activate from group
            };
            
            console.log("Adding new YouTube stream:", newSource);
            stateManager.addSource(newSource);
            
            // Auto-activate the new source
            setTimeout(async () => {
                const addedSource = stateManager.getSources().find(s => s.videoId === stream.videoId);
                if (addedSource) {
                    const sourceElement = document.querySelector(`[data-source-id="${addedSource.id}"]`);
                    const activateButton = sourceElement?.querySelector('[data-activatehtml]');
                    if (activateButton) {
                        await createWindow(activateButton);
                    }
                }
            }, 500);
        }
    }
    
    // Return true only if we found NEW streams (not just any streams)
    return newStreams.length > 0;
}

// Rumble auto-check functions
function startRumbleAutoCheck(sourceId) {
    // Clear any existing interval for this source
    stopRumbleAutoCheck(sourceId);
    
    const source = stateManager.getSource(sourceId);
    if (!source || !source.autoActivate || source.target !== 'rumble') return;
    
    console.log(`Starting auto-check for Rumble source: ${source.username}`);
    
    // Check immediately
    checkRumbleForStream(sourceId);
    
    // Then check every minute until a stream is found
    const intervalId = setInterval(() => {
        checkRumbleForStream(sourceId);
    }, 60000); // 60 seconds
    
    rumbleIntervals.set(sourceId, intervalId);
}

function stopRumbleAutoCheck(sourceId) {
    const intervalId = rumbleIntervals.get(sourceId);
    if (intervalId) {
        clearInterval(intervalId);
        rumbleIntervals.delete(sourceId);
        console.log(`Stopped auto-check for Rumble source: ${sourceId}`);
    }
}

async function checkRumbleForStream(sourceId) {
    const source = stateManager.getSource(sourceId);
    if (!source || source.target !== 'rumble') return;
    
    // Don't check if already activated
    if (source.status === 'active' && source.vid) {
        console.log(`Rumble source ${source.username} already active, stopping auto-check`);
        stopRumbleAutoCheck(sourceId);
        return;
    }
    
    console.log(`Checking for live stream for Rumble user: ${source.username}`);
    
    try {
        // Try to activate the source
        const sourceElement = document.querySelector(`[data-source-id="${sourceId}"]`);
        const activateButton = sourceElement?.querySelector('[data-activatehtml]');
        
        if (activateButton) {
            // Try to create the window
            const windowId = await createWindow(activateButton);
            
            if (windowId) {
                console.log(`Rumble stream found and activated for ${source.username}`);
                Toast.success("Rumble Stream Live", `${source.username} is now live on Rumble!`);
                
                // Stop checking since Rumble only allows one stream per user
                stopRumbleAutoCheck(sourceId);
            } else {
                console.log(`No live stream found for Rumble user ${source.username}, will check again in 1 minute`);
            }
        }
    } catch (error) {
        console.error("Error checking Rumble for stream:", error);
        // Keep checking on error
    }
}


function updateSourceUIAfterModeChange(sourceElement, mode, isActive = false) {
    if (!sourceElement) return;
    const sourceId = sourceElement.dataset.sourceId;
    const source = sourceId ? stateManager.getSource(sourceId) : null;
    
    const target = source ? source.target : sourceElement.dataset.target;

    const activateButton = sourceElement.querySelector('[data-activatehtml]');
    const controlPanel = sourceElement.querySelector('.control-panel');
    
    const classicModePanelButton = controlPanel?.querySelector('.mode-option[data-mode="classic"]');
    const wsModePanelButton = controlPanel?.querySelector('.mode-option[data-mode="websocket"]');

    const settingsMenu = sourceElement.querySelector('.settings-menu');
    const classicMenuItem = settingsMenu?.querySelector('.settings-menu-item[data-action="classic-mode"]');
    const wssMenuItem = settingsMenu?.querySelector('.settings-menu-item[data-wss="true"]');
    const tiktokWssMenuItem = settingsMenu?.querySelector('.settings-menu-item[data-tiktokwss="true"]');

    classicModePanelButton?.classList.remove('active');
    wsModePanelButton?.classList.remove('active');
    if (classicMenuItem) classicMenuItem.dataset.selected = "false";
    if (wssMenuItem) wssMenuItem.dataset.selected = "false";
    if (tiktokWssMenuItem) tiktokWssMenuItem.dataset.selected = "false";

    if (activateButton) { 
        if (isActive) { 
             activateButton.innerText = translate('btn.activate'); 
        } else {
            if (target === 'tiktok' && mode === 'tiktok-websocket') {
                activateButton.innerText = "Connect TikTok WebSocket";
            } else if (mode === 'websocket') {
                activateButton.innerText = "Connect WebSocket";
            } else { 
                activateButton.innerText = translate('btn.activate');
            }
        }
    }
    
    if (target === 'tiktok') {
        if (mode === 'tiktok-websocket') {
            if (tiktokWssMenuItem) tiktokWssMenuItem.dataset.selected = "true";
            // Don't hide the mode selector
        } else { 
            if (classicMenuItem) classicMenuItem.dataset.selected = "true";
            // Don't hide the mode selector
        }
    } else { 
        if (mode === 'websocket') {
            wsModePanelButton?.classList.add('active');
            if (wssMenuItem) wssMenuItem.dataset.selected = "true";
        } else { 
            classicModePanelButton?.classList.add('active');
            if (classicMenuItem) classicMenuItem.dataset.selected = "true";
        }
        // Don't hide the mode selector based on menu item visibility
    }
    
    // Update sign-in button visibility and behavior based on connection mode
    const signinButton = sourceElement.querySelector("[data-signin]");
    if (signinButton) {
        const isWebsocketMode = mode === 'websocket' || mode === 'tiktok-websocket';
        
        if (target === 'tiktok' && mode === 'tiktok-websocket') {
            // Show info instead of sign-in button for websocket mode
            signinButton.classList.remove("hidden");
            signinButton.setAttribute('data-tiktok-signin', 'true');
            signinButton.innerHTML = '📖 Read-Only Mode';
            signinButton.style.cursor = 'help';
            signinButton.title = 'WebSocket mode is read-only. Use Standard mode to send messages.';
            signinButton.onclick = function() { 
                Toast.info('TikTok WebSocket Mode', 'This mode is read-only due to TikTok API limitations. To send messages, please use Standard mode instead.');
            };
            
            // Check if already authenticated
            const source = stateManager.getSource(sourceId);
            if (source && source.tiktokSessionId) {
                signinButton.innerHTML = '✓ Signed In';
                signinButton.classList.add('authenticated');
            }
        } else if (isWebsocketMode) {
            // Hide for other websocket modes
            signinButton.classList.add("hidden");
        } else {
            // Regular sign-in button
            signinButton.classList.remove("hidden");
            signinButton.removeAttribute('data-tiktok-signin');
            signinButton.innerHTML = '🔑 Sign-in';
            signinButton.onclick = function() { signin(this); };
            signinButton.classList.remove('authenticated');
        }
    }
}


async function setSourceConnectionMode(sourceElement, mode, clickedMenuItemOrPanelButton) {
    if (!sourceElement) return;
    const sourceId = sourceElement.dataset.sourceId;
    if (!sourceId) return;

    const source = stateManager.getSource(sourceId);
    if (!source) return;

    console.log(`[Mode Switch] Setting connection mode for ${sourceId} from ${source.connectionMode} to ${mode}`);

    // If source is active, show a warning but don't prevent the mode change
    if (source.vid || source.wssId) { 
        Toast.warning("Mode Change", "Source is active. Stop it before activating with the new mode.");
    }

    stateManager.updateSource(sourceId, { connectionMode: mode });

    if (clickedMenuItemOrPanelButton && clickedMenuItemOrPanelButton.classList.contains('settings-menu-item')) {
        const mainActivateButton = sourceElement.querySelector('[data-activatehtml]');
        if (mainActivateButton && !mainActivateButton.classList.contains('hidden')) {
            await createWindow(mainActivateButton); 
        }
    }
}


function setupSourceControls(sourceElement) {
    if (!sourceElement) return;
    const sourceId = sourceElement.dataset.sourceId;
    
    const source = sourceId ? stateManager.getSource(sourceId) : null;
    const isGroupHeader = sourceElement.dataset.isGroupHeader === "true";


    const settingsBtn = sourceElement.querySelector('.settings-btn');
    const settingsMenu = sourceElement.querySelector('.settings-menu');
    if (!settingsBtn || !settingsMenu) return;

    const target = source ? source.target : sourceElement.dataset.target;
    const username = source ? source.username : sourceElement.dataset.username; 
    const controlPanel = sourceElement.querySelector('.control-panel');

    const classicMenuItem = settingsMenu.querySelector('.settings-menu-item[data-action="classic-mode"]');
    const wssMenuItem = settingsMenu.querySelector('.settings-menu-item[data-wss="true"]');
    const tiktokWssMenuItem = settingsMenu.querySelector('.settings-menu-item[data-tiktokwss="true"]');

    let isYouTube = target && target.startsWith('youtube');
    let isTikTok = target === 'tiktok';
    let genericWsSupported = false;
    
    // Check if platform supports websockets
    if (!isYouTube && !isTikTok && target) { 
        // Check manifest for websocket support
        genericWsSupported = manifest?.content_scripts?.some(cs => 
            cs.js?.some(jsFile => jsFile.includes(`websocket/${target}.js`))
        );
    }
    
    // For YouTube entries, websocket is supported
    if (isYouTube) {
        genericWsSupported = true;
    }
    
    if (isTikTok) {
        wssMenuItem?.classList.add('hidden');
        tiktokWssMenuItem?.classList.remove('hidden');
        
        // Add TikTok-specific mode selector
        let modeSelector = controlPanel?.querySelector('.mode-selector');
        if (!modeSelector && controlPanel) {
            modeSelector = document.createElement('div');
            modeSelector.className = 'mode-selector';
            modeSelector.innerHTML = `
                <div class="mode-selector-label">Connection Mode:</div>
                <div class="mode-options">
                    <div class="mode-option" 
                         data-mode="classic" 
                         onclick="setSourceConnectionMode(this.closest('.entry'), 'classic', this); updateModeSelector(this)">
                        📄 Standard
                    </div>
                    <div class="mode-option" 
                         data-mode="tiktok-websocket" 
                         onclick="setSourceConnectionMode(this.closest('.entry'), 'tiktok-websocket', this); updateModeSelector(this)">
                        🌐 TikTok WS
                    </div>
                </div>
                <div class="mode-info">
                    <span class="info-icon" title="TikTok WebSocket mode is READ-ONLY. You can view messages but cannot send them due to TikTok API limitations. Use Standard mode for full interaction.">ℹ️</span>
                </div>`;
            controlPanel.appendChild(modeSelector);
        }
        if (modeSelector) {
            modeSelector.classList.remove('hidden');
            // Update the active state based on current connection mode
            const currentMode = source?.connectionMode || 'tiktok-websocket';
            modeSelector.querySelectorAll('.mode-option').forEach(opt => {
                opt.classList.remove('active');
                if (opt.dataset.mode === currentMode) {
                    opt.classList.add('active');
                }
            });
        }
    } else {
        tiktokWssMenuItem?.classList.add('hidden');
        if (isYouTube || genericWsSupported) {
            wssMenuItem?.classList.remove('hidden');
            let modeSelector = controlPanel?.querySelector('.mode-selector');
            if (!modeSelector && controlPanel) { 
                modeSelector = document.createElement('div');
                modeSelector.className = 'mode-selector';
                modeSelector.innerHTML = `
                    <div class="mode-selector-label">Connection Mode:</div>
                    <div class="mode-options">
                        <div class="mode-option" 
                             data-mode="classic" 
                             onclick="setSourceConnectionMode(this.closest('.entry'), 'classic', this); updateModeSelector(this)">
                            📄 Standard
                        </div>
                        <div class="mode-option" 
                             data-mode="websocket" 
                             onclick="setSourceConnectionMode(this.closest('.entry'), 'websocket', this); updateModeSelector(this)">
                            🌐 WebSocket
                        </div>
                    </div>
                    <div class="mode-info">
                        <span class="info-icon" title="WebSocket mode uses less resources and provides additional data like followers/subs when signed in. Requires login for full features.">ℹ️</span>
                    </div>`;
                controlPanel.appendChild(modeSelector);
            }
            if (modeSelector) {
                modeSelector.classList.remove('hidden');
                // Update the active state based on current connection mode
                const currentMode = source?.connectionMode || 'classic';
                modeSelector.querySelectorAll('.mode-option').forEach(opt => {
                    opt.classList.remove('active');
                    if (opt.dataset.mode === currentMode) {
                        opt.classList.add('active');
                    }
                });
            }
        } else { 
            wssMenuItem?.classList.add('hidden');
            // Don't remove the mode selector if it exists
        }
    }

    const autoActivateToggleDiv = controlPanel?.querySelector('.auto-activate-toggle');
    if (autoActivateToggleDiv) {
        const checkbox = autoActivateToggleDiv.querySelector('input[type="checkbox"]');
        if (checkbox) {
            checkbox.onchange = () => {
                if (sourceId) { 
                    stateManager.updateSource(sourceId, { autoActivate: checkbox.checked });
                } else if (isGroupHeader && sourceElement.dataset.groupId) { 
                    stateManager.updateGroup(sourceElement.dataset.groupId, { autoActivate: checkbox.checked });
                }
            };
        }
    }

    settingsBtn.onclick = (e) => {
        e.stopPropagation();
        document.querySelectorAll('.settings-menu.active').forEach(menu => {
            if (menu !== settingsMenu) menu.classList.remove('active');
        });
        settingsMenu.classList.toggle('active');

        const currentSource = sourceId ? stateManager.getSource(sourceId) : null;
        const isActive = currentSource ? (!!currentSource.vid || !!currentSource.wssId) : false;
        const currentMode = currentSource ? currentSource.connectionMode : (sourceElement.dataset.lastConnectionMode || 'classic');

        settingsMenu.querySelectorAll('.connection-modes .settings-menu-item').forEach(item => {
            if (item.classList.contains('hidden')) return; 

            const itemMode = item.dataset.action === 'classic-mode' ? 'classic' :
                             item.dataset.wss === 'true' ? 'websocket' :
                             item.dataset.tiktokwss === 'true' ? 'tiktok-websocket' : null;

            const isSelected = itemMode === currentMode;
            item.dataset.selected = isSelected.toString(); 

            if (isActive) { 
                if (isSelected) { 
                    item.style.opacity = '1';
                    item.style.pointerEvents = 'auto';
                    item.title = 'Click to stop current connection';
                    const icon = item.querySelector('i');
                    if (icon) icon.textContent = '⏹️'; 
                } else { 
                    item.style.opacity = '0.5';
                    item.style.pointerEvents = 'none';
                    item.title = 'Stop current connection to change/activate another mode.';
                    const icon = item.querySelector('i');
                    if (icon) {
                        if (item.dataset.action === 'classic-mode') icon.textContent = '📄';
                        else if (item.dataset.wss === 'true' || item.dataset.tiktokwss === 'true') icon.textContent = '🌐';
                    }
                }
            } else { 
                item.style.opacity = '1';
                item.style.pointerEvents = 'auto';
                const icon = item.querySelector('i');
                if (item.dataset.action === 'classic-mode') {
                    item.title = 'Use standard browser window for this source';
                    if (icon) icon.textContent = '📄';
                } else if (item.dataset.wss === 'true') {
                    item.title = 'Connect to the API directly using WebSocket';
                     if (icon) icon.textContent = '🌐';
                } else if (item.dataset.tiktokwss === 'true') {
                    item.title = 'Connect to the TikTok API directly using WebSockets';
                    if (icon) icon.textContent = '🌐';
                } else {
                    item.title = '';
                }
            }
        });
    };
    document.addEventListener('click', (e) => { 
        if (!settingsMenu.classList.contains('active')) return;
        if (!settingsMenu.contains(e.target) && !settingsBtn.contains(e.target)) {
            settingsMenu.classList.remove('active');
        }
    });

    if (source) {
        updateSourceUIAfterModeChange(sourceElement, source.connectionMode, (source.status === 'active'));
    } else if (!isGroupHeader) { 
        updateSourceUIAfterModeChange(sourceElement, 'classic', false);
    }
}

function setClassicMode(menuItemElement) { 
    const sourceElement = menuItemElement.closest('.entry');
    if (!sourceElement) return;
    setSourceConnectionMode(sourceElement, 'classic', menuItemElement);
}

async function activateSource(ele) {
    const parentElement = ele.closest('.entry');
    if (!parentElement) {
        console.error("activateSource: Could not find parent .entry");
        return;
    }
    await createWindow(ele);
}

/* Modified toggleSourceVisibility */
function toggleSourceVisibility(ele) {
    const entry = ele.closest('.entry');
    if (!entry) return;
    const sourceId = entry.dataset.sourceId;
    const source = stateManager.getSource(sourceId);
    if (!source || !source.vid) {
        Toast.info("Info", "Source must be active to toggle visibility.");
        return;
    }
    
    const desiredUiState = !source.isVisible; // What the UI should become

    // Because main.js showWindow handler has inverted logic for explicit state:
    // if desiredUiState is true (want to show), send state: false to main
    // if desiredUiState is false (want to hide), send state: true to main
    const stateToSendToMain = !desiredUiState;

    console.log(`toggleSourceVisibility: sourceId=${sourceId}, current IsVisible=${source.isVisible}, desired UI State=${desiredUiState}, sending to main=${stateToSendToMain}`);

    if (!ipcRenderer) {
        console.error("ipcRenderer not available for toggleSourceVisibility");
        Toast.error("IPC Error", "Cannot communicate with main process.");
        return;
    }

    
    ipcRenderer.invoke('showWindow', {
        vid: source.vid,
        state: stateToSendToMain 
    }).then(responseFromMain => {
        // responseFromMain should be the *actual* new visibility state from main process
        let actualNewState = desiredUiState; // Default to desired if main doesn't respond clearly

        if (responseFromMain !== undefined && typeof responseFromMain.newState === 'boolean') {
            actualNewState = responseFromMain.newState;
        } else if (typeof responseFromMain === 'boolean') { // If main process just returns the boolean state
            actualNewState = responseFromMain;
        } else {
             console.warn('toggleSourceVisibility: Unexpected response from main process for showWindow IPC. Assuming desired state.', responseFromMain);
        }
        
        console.log(`toggleSourceVisibility: main process responded with actualNewState=${actualNewState}. Updating stateManager.`);
        stateManager.updateSource(sourceId, { isVisible: actualNewState });

    }).catch(error => {
        console.error("Error in toggleSourceVisibility IPC:", error);
        Toast.error("Visibility Error", "Could not toggle window visibility. Check console for details.");
        // Optionally, revert UI or state if IPC fails catastrophically, though sourceUpdated should handle UI
    });
}


function toggleSourceMute(ele) {
    const entry = ele.closest('.entry');
    if (!entry) return;
    const sourceId = entry.dataset.sourceId;
    const source = stateManager.getSource(sourceId);
    if (!source) return;

    const newMuteState = !source.isMuted;
    console.log(`Toggling mute for ${sourceId}: ${source.isMuted} -> ${newMuteState}`);
    
    // Update the state first
    stateManager.updateSource(sourceId, { isMuted: newMuteState });
    
    // Update UI immediately
    const button = ele;
    button.textContent = newMuteState ? '🔇' : '🔊';
    
    // If the window is active, also update the actual mute state
    if (source.vid && ipcRenderer) {
        console.log(`Sending mute command to window ${source.vid}: ${newMuteState}`);
        ipcRenderer.sendSync('muteWindow', {
            vid: source.vid,
            muteWindow: newMuteState
        });
    }
    
    // Verify the state was saved
    const updatedSource = stateManager.getSource(sourceId);
    console.log(`Mute state after update: ${updatedSource.isMuted}`);
}

async function deleteThis(ele) {
    const entry = ele.closest('.entry');
    if (!entry) return;

    const sourceId = entry.dataset.sourceId;
    const groupId = entry.dataset.groupId;

    if (sourceId) { 
        const source = stateManager.getSource(sourceId);
        if (source) {
            if (source.wssId && source.target === 'tiktok') {
                try {
                    if (ipcRenderer) await ipcRenderer.sendSync('disconnectTikTokConnection', { wssID: source.wssId });
                } catch (e) { console.warn('Error disconnecting TikTok WSS during delete:', e); }
            } else if (source.vid) { 
                try {
                    if (ipcRenderer) await ipcRenderer.sendSync('closeWindow', { vid: source.vid });
                } catch (e) { console.warn('Error closing window/WSS during delete:', e); }
            }
            stateManager.removeSource(sourceId); 
        }
    } else if (groupId) { 
        const group = stateManager.getGroup(groupId);
        if (group) {
            stateManager.removeGroup(groupId); 
        }
    }
    manageWelcomePage();
}


async function stopThis(ele) {
    const entry = ele.closest('.entry');
    if (!entry) return;
    const sourceId = entry.dataset.sourceId;
    if (!sourceId) return;

    const source = stateManager.getSource(sourceId);
    if (!source) return;
    
    if (ele.dataset.connecting === "true" && source.target === 'tiktok' && source.connectionMode === 'tiktok-websocket') {
        if (source.wssId && ipcRenderer) { 
            try {
                await ipcRenderer.sendSync('disconnectTikTokConnection', { wssID: source.wssId });
            } catch (e) { console.warn("Error stopping TikTok connection attempt:", e); }
        }
        stateManager.updateSource(sourceId, { status: 'inactive', vid: null, wssId: null });
        updateConnectionStatus(entry, 'stopped', "Connection attempts stopped");
        return;
    }

    if (source.vid || source.wssId) {
        try {
            if (source.target === 'tiktok' && source.connectionMode === 'tiktok-websocket' && source.wssId && ipcRenderer) {
                await ipcRenderer.sendSync('disconnectTikTokConnection', { wssID: source.wssId });
            } else if (source.vid && ipcRenderer) { 
                await ipcRenderer.sendSync('closeWindow', { vid: source.vid });
            }
        } catch (error) {
            console.error('Error in stopThis during IPC call:', error);
        }
        stateManager.updateSource(sourceId, { status: 'inactive', vid: null, wssId: null });
        if (source.target === 'tiktok') updateConnectionStatus(entry, 'clear');
        
        // For Rumble sources, clear video ID and chat ID for username-based sources
        if (source.target === 'rumble' && source.username && (source.videoId || source.chatId)) {
            stateManager.updateSource(sourceId, { videoId: null, chatId: null, url: null });
        }
        
        // Restart auto-check for Rumble sources with auto-activate
        if (source.target === 'rumble' && source.autoActivate) {
            console.log(`Restarting auto-check for deactivated Rumble source: ${source.username}`);
            setTimeout(() => {
                startRumbleAutoCheck(sourceId);
            }, 1000); // Small delay before restarting
        }
    }
}


async function clearThis(ele) {
	const entry = ele.closest('.entry');
    if (!entry) return;
    
    let idsToClear = [];
    const sourceId = entry.dataset.sourceId;
    const groupId = entry.dataset.groupId;

    if (sourceId) {
        const source = stateManager.getSource(sourceId);
        if (source && source.vid) idsToClear.push(source.vid);
    } else if (groupId) {
        const group = stateManager.getGroup(groupId);
        if (group) {
            group.streams.forEach(sId => {
                const stream = stateManager.getSource(sId);
                if (stream && stream.vid) idsToClear.push(stream.vid);
            });
        }
    }

	if (idsToClear.length === 0) {
		Toast.info("Info", "No active sources to clear cache for.");
		return;
	}

    const buttonText = ele.textContent;
    ele.textContent = idsToClear.length > 1 ? 'Clearing All...' : 'Clearing...';
    ele.disabled = true;

    for (const vid of idsToClear) {
        if (ipcRenderer) {
            try {
                const result = await ipcRenderer.invoke('clearWindowCache', vid); 
                if (!result.success) {
                    console.error('Failed to clear cache for', vid, result.error);
                    Toast.error("Error", `Cache clear failed for source window ${vid}.`);
                }
            } catch (error) {
                console.error('Error invoking clearWindowCache for', vid, error);
                Toast.error("Error", `Error clearing cache for source window ${vid}.`);
            }
        }
    }
    Toast.success("Success", `Cache cleared for ${idsToClear.length} source(s).`);
    ele.textContent = buttonText;
    ele.disabled = false;
}

async function refreshWindow(ele) {
	const entry = ele.closest('.entry');
    if (!entry) return;
    const sourceId = entry.dataset.sourceId;
    if (!sourceId) return;

    const source = stateManager.getSource(sourceId);
	if (source && source.vid && ipcRenderer) {
		ipcRenderer.sendSync('reloadWindow', { 
			tab: source.vid 
		});
	};
}

async function createWindow(ele, tabid = false) { 
	if (!ele) { console.error('No element provided to createWindow'); return false; }
	if (!configReady) { 
        Toast.error("Config Error", "Configuration not ready. Please wait or check console.");
        return false;
    }

	const entry = ele.closest('.entry');
	if (!entry) { console.error("Could not find entry for createWindow"); return false; }
    
    const sourceId = entry.dataset.sourceId;
    if (!sourceId) { console.error("No sourceId on entry for createWindow"); return false; }

    const source = stateManager.getSource(sourceId);
    console.log(`[CREATEWINDOW DEBUG] Source ID: ${sourceId}, Source:`, source);
    if (!source) { console.error("Source not found in stateManager:", sourceId); return false; }

    const target = source.target; // Move this declaration up before it's used

	if (source.vid || source.wssId) {
		console.log('Window/connection already active for this entry:', source.vid || source.wssId);
		console.log(`[Window Mapping Debug] Source ${sourceId} state:`, {
			vid: source.vid,
			wssId: source.wssId,
			connectionMode: source.connectionMode,
			target: source.target,
			username: source.username
		});
		
		// Check if we're switching connection modes
		const currentMode = source.connectionMode;
		const isTikTokModeSwitch = target === 'tiktok' && 
			((currentMode === 'tiktok-websocket' && source.vid && source.vid < 900000) || // Was classic, now websocket
			 (currentMode === 'classic' && source.vid && source.vid > 900000)); // Was websocket, now classic
		
		if (isTikTokModeSwitch) {
			console.log(`[Mode Switch] Switching TikTok from ${source.vid > 900000 ? 'websocket' : 'classic'} to ${currentMode}`);
			// Close the old connection/window
			try {
				if (source.vid > 900000 && source.wssId) {
					// Close websocket connection
					await ipcRenderer.sendSync('disconnectTikTokConnection', { wssID: source.wssId });
				} else if (source.vid) {
					// Close classic window
					await ipcRenderer.sendSync('closeWindow', { vid: source.vid });
				}
			} catch (e) {
				console.warn('Error closing old connection during mode switch:', e);
			}
			// Clear the old IDs
			stateManager.updateSource(sourceId, { vid: null, wssId: null, status: 'inactive' });
		} else {
			// Verify the window actually exists before reusing the ID
			if (source.vid && ipcRenderer) {
				const windowExists = await ipcRenderer.invoke('checkWindowExists', { vid: source.vid });
				if (!windowExists) {
					stateManager.updateSource(sourceId, { vid: null, wssId: null, status: 'inactive' });
				} else {
					return source.vid;
				}
			} else if (source.wssId && target === 'tiktok' && currentMode === 'tiktok-websocket') {
				// For TikTok websocket, we need to check if the connection still exists
				// The wssId alone doesn't mean the connection is active
				// Clear the stale wssId and allow new connection
				stateManager.updateSource(sourceId, { vid: null, wssId: null, status: 'inactive' });
				return false;
			} else if (source.wssId) {
				return source.wssId;
			}
		}
	}

    let mode = source.connectionMode;
    // target already declared above
    
    // Validate connection mode - force classic for platforms without websocket support
    if (mode === 'websocket' && !source.supportsWSS) {
        // Check WebSocket support if not already stored
        const hasWebSocketSupport = (target === 'tiktok') || 
            (typeof manifest !== 'undefined' && manifest?.content_scripts?.some(cs => 
                cs.js?.some(jsFile => jsFile.includes(`websocket/${target}.js`))
            ));
        
        if (!hasWebSocketSupport) {
            console.log(`Platform ${target} doesn't support websocket, switching to classic mode`);
            mode = 'classic';
            // Update the source to reflect the correct mode
            stateManager.updateSource(sourceId, { connectionMode: 'classic', supportsWSS: false });
        }
    }
    
    let windowId; 

	try {
        stateManager.updateSource(sourceId, { status: 'activating' }); 

        if (mode === 'tiktok-websocket' && target === 'tiktok') {
            windowId = await createTikTokWSSFromSource(source); 
        } else if (mode === 'websocket') {
            if (target && target.startsWith('youtube')) {
                windowId = await createYoutubeWebSocketWindowFromSource(source, tabid);
            } else { 
                 windowId = await createWindowWSSFromSource(source, tabid);
            }
        } else { 
			windowId = await createClassicWindowFromSource(source, tabid);
		}

        if (windowId) { 
            
            // For TikTok websocket, windowId is the virtual tab ID (900000+wssId)
            // We need to extract the actual wssId
            let actualWssId = null;
            if (mode === 'tiktok-websocket' && windowId > 900000) {
                actualWssId = windowId - 900000;
            } else if (mode.includes('websocket')) {
                actualWssId = windowId;
            }
            
            stateManager.updateSource(sourceId, {
                vid: windowId, 
                wssId: actualWssId, 
                status: 'active'
            });
            
            // Verify the assignment immediately
            const verifySource = stateManager.getSource(sourceId);
        } else {
            console.warn(`Activation failed for source ${sourceId}, windowId was:`, windowId);
            stateManager.updateSource(sourceId, { status: 'inactive', vid: null, wssId: null });
            Toast.error("Activation Failed", `Could not activate ${source.username || source.target}. Main process might have failed.`);
        }
        return windowId; 
	} catch (error) {
		console.error(`Error in createWindow for source ${sourceId} (mode: ${mode}):`, error);
        stateManager.updateSource(sourceId, { status: 'error', error: error.message, vid: null, wssId: null });
		return false; 
	}
}

// Helper function to fetch with retries
async function fetchWithRetry(url, options = {}, maxRetries = 3) {
    let lastError;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            console.log(`Fetch attempt ${attempt} for ${url} with timeout of ${options.timeout || 10000}`);
            const response = await ipcRenderer.invoke('nodefetch', {
                url,
                ...options,
                timeout: options.timeout || 10000
            });
            
            if (!response) {
                throw new Error("No response received");
            }
            
            if (response.error) {
                throw new Error(response.error);
            }
            
            if (response.status && response.status >= 500) {
                throw new Error(`Server error: ${response.status}`);
            }
            
            return response;
        } catch (error) {
            lastError = error;
            console.warn(`Fetch attempt ${attempt} failed:`, error.message);
            
            if (attempt < maxRetries) {
                // Exponential backoff: 1s, 2s, 4s
                const delay22 = Math.pow(2, attempt - 1) * 5000;
                console.log(`Retrying in ${delay22}ms...`);
                await new Promise(resolve => setTimeout(resolve, delay22));
            }
        }
    }
    
    throw lastError;
}

async function createClassicWindowFromSource(source, tabid = false) {
    if (!ipcRenderer) return false;
    let urlToLoad = source.url;

    if (source.target?.startsWith("youtube") && source.videoId && (!urlToLoad || !urlToLoad.includes(source.videoId))) {
        const isShort = source.target === "youtubeshorts";
        if (source.videoId) { 
             urlToLoad = `https://www.youtube.com/live_chat?is_popout=1&v=${source.videoId}${isShort ? '&shorts' : ''}`;
             if (source.url !== urlToLoad) {
                stateManager.updateSource(source.id, { url: urlToLoad });
             }
        } else if (source.username) { 
            console.log("Attempting to fetch video ID for YouTube classic activation:", source.username);
            const videoDescArray = await fetchYoutube(source.username, false) || await fetchYoutube(source.username, true);
            if (videoDescArray && videoDescArray.length > 0) {
                const videoDesc = videoDescArray[0];
                stateManager.updateSource(source.id, { videoId: videoDesc.videoId }); 
                urlToLoad = `https://www.youtube.com/live_chat?is_popout=1&v=${videoDesc.videoId}${isShort ? '&shorts' : ''}`;
                stateManager.updateSource(source.id, { url: urlToLoad });
            } else {
                 Toast.error("YouTube Error", `No live video found for ${source.username} to activate in classic mode.`);
                return false;
            }
        }
    } else if (source.target === "rumble" && source.username && !source.chatId && !source.isDirectUrl) {
        // Skip fetching if we already have a chat popup URL
        if (source.url && source.url.includes('/chat/popup/')) {
            console.log("Already have chat popup URL, skipping fetch");
            urlToLoad = source.url;
        } else if (/^\d+$/.test(source.username)) {
            // Check if the username is actually a numeric chat ID
            console.log(`Username appears to be a numeric chat ID: ${source.username}`);
            const chatId = source.username;
            urlToLoad = `https://rumble.com/chat/popup/${chatId}`;
            stateManager.updateSource(source.id, { url: urlToLoad, chatId: chatId });
        } else {
            // For username-based Rumble sources, always fetch fresh video ID
            console.log("Attempting to fetch video ID for Rumble:", source.username);
            let videoId = null;
        
        // Try the primary option first (channel if isChannel is true, user otherwise)
        const tryChannelFirst = source.isChannel !== false; // Default to channel if not specified
        let videoInfo = await fetchRumble(source.username, !tryChannelFirst);
        
        // If not found, try the alternate option
        if (!videoInfo) {
            console.log("Rumble video not found with primary option, trying alternate...");
            videoInfo = await fetchRumble(source.username, tryChannelFirst);
        }
        
        if (videoInfo) {
            // Handle both old format (string) and new format (object)
            videoId = typeof videoInfo === 'string' ? videoInfo : videoInfo.videoId;
            const fullPath = typeof videoInfo === 'string' ? `${videoInfo}.html` : videoInfo.fullPath;
            
            // Fetch the chat ID from the video page
            console.log(`Fetching Rumble chat ID for video: ${videoId} (path: ${fullPath})`);
            const videoUrl = `https://rumble.com/${fullPath}`;
            
            try {
                const response = await fetchWithRetry(videoUrl, {
                    headers: {'User-Agent': config?.global?.userAgent || 'Mozilla/5.0'},
                    timeout: 10000
                }, 2); // Only 2 retries for Rumble to prevent long freezes
                
                if (response.status && response.status !== 200) {
                    console.error(`Rumble fetch returned status ${response.status}`);
                    if (response.status === 404) {
                        Toast.error("Rumble Error", `Video not found: ${videoUrl}`);
                    } else {
                        Toast.error("Rumble Error", `Rumble returned error ${response.status}`);
                    }
                    return false;
                }
                
                const htmlData = response?.data || response;
                if (htmlData && typeof htmlData === 'string') {
                    
                    // Try multiple patterns to find the numeric video/chat ID
                    let chatId = null;
                    
                    // Pattern 1: data-video-id attribute
                    const dataVideoIdMatch = htmlData.match(/data-video-id=["'](\d+)["']/);
                    if (dataVideoIdMatch && dataVideoIdMatch[1]) {
                        chatId = dataVideoIdMatch[1];
                    }
                    
                    // Pattern 2: content_id in hx-vals
                    if (!chatId) {
                        const contentIdMatch = htmlData.match(/&#34;content_id&#34;:(\d+)/);
                        if (contentIdMatch && contentIdMatch[1]) {
                            chatId = contentIdMatch[1];
                        }
                    }
                    
                    // Pattern 3: video_id in JavaScript
                    if (!chatId) {
                        const videoIdMatch = htmlData.match(/video_id:\s*(\d+)/);
                        if (videoIdMatch && videoIdMatch[1]) {
                            chatId = videoIdMatch[1];
                        }
                    }
                    
                    // Pattern 4: cvid in window.rads
                    if (!chatId) {
                        const cvidMatch = htmlData.match(/cvid:(\d+)/);
                        if (cvidMatch && cvidMatch[1]) {
                            chatId = cvidMatch[1];
                        }
                    }
                    
                    if (chatId) {
                        console.log(`Found Rumble chat ID: ${chatId} for video: ${videoId}`);
                        stateManager.updateSource(source.id, { videoId: videoId, chatId: chatId });
                        urlToLoad = `https://rumble.com/chat/popup/${chatId}`;
                        stateManager.updateSource(source.id, { url: urlToLoad });
                    } else {
                        // Debug: look for any numeric IDs
                        const numericIds = htmlData.match(/\b\d{9,10}\b/g);
                        if (numericIds) {
                        }
                        console.warn(`Could not find chat ID for Rumble video: ${videoId}`);
                        Toast.error("Rumble Error", `Could not find chat ID for video ${videoId}`);
                        return false;
                    }
                } else {
                    console.error("Invalid response when fetching Rumble video page");
                    return false;
                }
            } catch (e) {
                console.error("Error fetching Rumble chat ID:", e);
                if (e.message.includes("timeout")) {
                    Toast.error("Rumble Error", "Connection timed out. Rumble might be slow or unreachable.");
                } else {
                    Toast.error("Rumble Error", `Failed to get chat ID: ${e.message}`);
                }
                return false;
            }
            } else {
                Toast.error("Rumble Error", `No live video found for ${source.username}.`);
                return false;
            }
        }
    } else if (source.target === "rumble" && source.chatId) {
        // Direct chat ID provided
        console.log("Using provided chat ID:", source.chatId);
        urlToLoad = `https://rumble.com/chat/popup/${source.chatId}`;
    } else if (source.target === "rumble" && source.isDirectUrl) {
        // Direct Rumble URL that should be used as-is
        console.log("Using direct Rumble URL:", source.url);
        urlToLoad = source.url;
    } else if (source.target === "rumble" && source.videoId && !source.username) {
        // For direct video ID entries, we need to fetch the chat ID
        {
            // Check if the videoId is actually a numeric chat ID
            if (/^\d+$/.test(source.videoId) && source.videoId.length >= 8) {
                // This looks like a chat ID, not a video ID
                console.log(`Video ID appears to be a chat ID: ${source.videoId}`);
                urlToLoad = `https://rumble.com/chat/popup/${source.videoId}`;
                stateManager.updateSource(source.id, { chatId: source.videoId, url: urlToLoad });
            } else {
                // We need to fetch the chat ID
                console.log(`Direct video ID entry needs chat ID, fetching...`);
                try {
                    let videoUrl;
                    
                    // Check if this is a full path or just a video ID
                    if (source.videoId.includes('-') || source.videoId.includes('.html')) {
                        // This looks like a full path
                        videoUrl = `https://rumble.com/${source.videoId}`;
                    } else if (/^[vp]\w+$/.test(source.videoId)) {
                        // This is just a video ID, we need to construct a URL
                        // Unfortunately, we can't know the full path without additional info
                        // Let's try the simple format first
                        videoUrl = `https://rumble.com/${source.videoId}.html`;
                    } else {
                        // Unknown format, try as-is
                        videoUrl = `https://rumble.com/${source.videoId}`;
                    }
                    
                    console.log(`Fetching Rumble page: ${videoUrl}`);
                    const response = await fetchWithRetry(videoUrl, {
                        headers: {'User-Agent': config?.global?.userAgent || 'Mozilla/5.0'},
                        timeout: 10000
                    }, 2); // Only 2 retries for Rumble to prevent long freezes
                
                if (response.status && response.status !== 200) {
                    console.error(`Rumble fetch returned status ${response.status}`);
                    if (response.status === 404) {
                        Toast.error("Rumble Error", `Video not found: ${videoUrl}`);
                    } else {
                        Toast.error("Rumble Error", `Rumble returned error ${response.status}`);
                    }
                    return false;
                }
                
                const htmlData = response?.data || response;
                if (htmlData && typeof htmlData === 'string') {
                    
                    // Try multiple patterns to find the numeric video/chat ID
                    let chatId = null;
                    
                    // Pattern 1: data-video-id attribute
                    const dataVideoIdMatch = htmlData.match(/data-video-id=["'](\d+)["']/);
                    if (dataVideoIdMatch && dataVideoIdMatch[1]) {
                        chatId = dataVideoIdMatch[1];
                    }
                    
                    // Pattern 2: content_id in hx-vals
                    if (!chatId) {
                        const contentIdMatch = htmlData.match(/&#34;content_id&#34;:(\d+)/);
                        if (contentIdMatch && contentIdMatch[1]) {
                            chatId = contentIdMatch[1];
                        }
                    }
                    
                    // Pattern 3: video_id in JavaScript
                    if (!chatId) {
                        const videoIdMatch = htmlData.match(/video_id:\s*(\d+)/);
                        if (videoIdMatch && videoIdMatch[1]) {
                            chatId = videoIdMatch[1];
                        }
                    }
                    
                    // Pattern 4: cvid in window.rads
                    if (!chatId) {
                        const cvidMatch = htmlData.match(/cvid:(\d+)/);
                        if (cvidMatch && cvidMatch[1]) {
                            chatId = cvidMatch[1];
                        }
                    }
                    
                    if (chatId) {
                        console.log(`Found Rumble chat ID: ${chatId} for video: ${source.videoId}`);
                        stateManager.updateSource(source.id, { chatId: chatId });
                        urlToLoad = `https://rumble.com/chat/popup/${chatId}`;
                        stateManager.updateSource(source.id, { url: urlToLoad });
                    } else {
                        Toast.error("Rumble Error", `Could not find chat ID for video ${source.videoId}`);
                        return false;
                    }
                }
            } catch (e) {
                console.error("Error fetching Rumble chat ID:", e);
                if (e.message.includes("timeout")) {
                    Toast.error("Rumble Error", "Connection timed out. Rumble might be slow or unreachable.");
                } else {
                    Toast.error("Rumble Error", `Failed to get chat ID: ${e.message}`);
                }
                return false;
            }
            }
        }
    }
    
    if (!urlToLoad) {
        Toast.error("Activation Error", `No URL specified for ${source.username || source.target} (classic mode).`);
        return false;
    }
    
    let conf = config.global ? { ...config.global } : {};
    if (config[source.target]) conf = { ...conf, ...config[source.target] };

    // Apply custom user agent if set
    if (source.userAgent && source.userAgent !== 'AUTO') {
        conf.userAgent = source.userAgent;
        console.log('[CreateClassicWindow] Using custom user agent:', source.userAgent);
    } else {
        console.log('[CreateClassicWindow] Using AUTO user agent from config:', conf.userAgent);
    }

    const targetSourceFile = source.target === "youtubeshorts" ? "youtube" : source.target;
    const scriptPath = source.sourceFile || `sources/${targetSourceFile}.js`; // Use sourceFile from state if available

    try {
        // For now, fall back to sync while we debug the async issue
        const response = ipcRenderer.sendSync('createWindow', {
            url: rewriteKickUrl(urlToLoad),
            config: conf,
            visible: source.isVisible,
            muted: source.isMuted,
            source: scriptPath, 
            tab: tabid,
            sourceId: source.id,
            customSession: source.customSession || 'AUTO',
            isBetaMode: isBetaMode,
            domain: new URL(urlToLoad).hostname
        });
        return response;
        
        // TODO: Fix async implementation
        /*
        const response = await window.ipc.send('createWindow', {
            url: rewriteKickUrl(urlToLoad),
            config: conf,
            visible: source.isVisible,
            muted: source.isMuted,
            source: scriptPath, 
            tab: tabid,
            isBetaMode: isBetaMode,
            domain: new URL(urlToLoad).hostname
        });
        return response; 
        */
    } catch(e) {
        console.error("Error in createClassicWindowFromSource:", e);
        Toast.error("Window Error", `Failed to create classic window: ${e.message}`);
        return false;
    }
}

async function createWindowWSSFromSource(source, tabid = false) {
    if (!ipcRenderer) return false;
    let conf = config.global ? { ...config.global } : {};
    if (config[source.target]) conf = { ...conf, ...config[source.target] };
    if (conf.wss) conf = { ...conf, ...conf.wss };

    // Apply custom user agent if set
    if (source.userAgent && source.userAgent !== 'AUTO') {
        conf.userAgent = source.userAgent;
        console.log('[CreateWindowWSS] Using custom user agent:', source.userAgent);
    } else {
        console.log('[CreateWindowWSS] Using AUTO user agent from config:', conf.userAgent);
    }

    let urlWSS;
    if (devmode || sourcemode) {
        const baseUrl = sourcemode || 'http://localhost:8080/';
        urlWSS = `${baseUrl}sources/websocket/${source.target}.html?channel=${source.username}`;
        if (devmode) urlWSS += '&devmode=';
    } else {
        const domain = isBetaMode ? 'https://socialstream.ninja/beta/' : 'https://socialstream.ninja/';
        urlWSS = `${domain}sources/websocket/${source.target}.html?channel=${source.username}`;
    }
    
    const scriptPath = source.sourceFile || `sources/websocket/${source.target}.js`;


    try {
        // For now, fall back to sync while we debug the async issue
        const response = ipcRenderer.sendSync('createWindow', {
            url: rewriteKickUrl(urlWSS.trim()),
            muted: source.isMuted,
            visible: source.isVisible,
            source: scriptPath, 
            tab: tabid,
            sourceId: source.id,
            customSession: source.customSession || 'AUTO',
            wss: true,
            config: conf,
            isBetaMode: isBetaMode
        });
        return response; 
    } catch (e) {
        console.error("Error in createWindowWSSFromSource:", e);
        Toast.error("WebSocket Error", `Failed to create WebSocket window: ${e.message}`);
        return false;
    }
}

async function createYoutubeWebSocketWindowFromSource(source, tabid = false) {
    if (!ipcRenderer) return false;
    let conf = config.global ? { ...config.global } : {};
    if (config[source.target]) conf = { ...conf, ...config[source.target] }; 
    if (conf.wss) conf = { ...conf, ...conf.wss };

    // Apply custom user agent if set
    if (source.userAgent && source.userAgent !== 'AUTO') {
        conf.userAgent = source.userAgent;
        console.log('[CreateYouTubeWSS] Using custom user agent:', source.userAgent);
    } else {
        console.log('[CreateYouTubeWSS] Using AUTO user agent from config:', conf.userAgent);
    }

    const queryParams = new URLSearchParams();
    if (source.videoId) queryParams.set('videoId', source.videoId);
    else if (source.username) queryParams.set('channel', source.username);
    else {
        Toast.error("YouTube WSS Error", "Missing Video ID or Username for YouTube WebSocket.");
        return false;
    }

    let baseUrl;
    if (devmode || sourcemode) {
        baseUrl = sourcemode ? `${sourcemode}sources/websocket/youtube.html` : `http://localhost:8080/sources/websocket/youtube.html`;
        if (devmode && !queryParams.has('devmode')) queryParams.set('devmode','');
    } else {
        const domain = isBetaMode ? 'https://socialstream.ninja/beta/' : 'https://socialstream.ninja/';
        baseUrl = `${domain}sources/websocket/youtube.html`;
    }
    const urlWSS = `${baseUrl}?${queryParams.toString()}`;
    
    // For YouTube WSS, the script path is specific
    const scriptPath = devmode || sourcemode ? 
                       (sourcemode ? `${sourcemode}sources/websocket/youtube.js` : `http://localhost:8080/sources/websocket/youtube.js`) : 
                       (isBetaMode ? 'https://socialstream.ninja/beta/sources/websocket/youtube.js' : 'https://socialstream.ninja/sources/websocket/youtube.js');

    try {
        const response = ipcRenderer.sendSync('createWindow', {
            url: rewriteKickUrl(urlWSS.trim()),
            muted: source.isMuted,
            visible: source.isVisible,
            source: scriptPath,
            tab: tabid,
            sourceId: source.id,
            customSession: source.customSession || 'AUTO',
            wss: true,
            config: conf,
            isBetaMode: isBetaMode
        });
         return response; 
    } catch (e) {
        console.error("Error in createYoutubeWebSocketWindowFromSource IPC call:", e, "URL:", urlWSS, "Script:", scriptPath);
        Toast.error("YouTube WSS Error", `Failed to create YouTube WebSocket: ${e.message}`);
        return false;
    }
}

async function createTikTokWSSFromSource(source) { 
    if (!ipcRenderer) return false;
    const cleanUsername = source.username?.replace('@', '').trim();
    if (!cleanUsername) {
        Toast.warning("TikTok WSS Error", 'No username found for TikTok connection');
        return false;
    }

    updateConnectionStatus(document.querySelector(`[data-source-id="${source.id}"]`), 'connecting');

    try {
        // Check if we have stored credentials for this source
        const sessionId = source.tiktokSessionId || null;
        const ttTargetIdc = source.tiktokTtTargetIdc || null;
        
        const wssID = ipcRenderer.sendSync('createTikTokConnection', { 
            username: cleanUsername,
            sessionId: sessionId,
            ttTargetIdc: ttTargetIdc
        }); 
        
        if (wssID === null || typeof wssID === 'undefined') { 
            throw new Error('Failed to create TikTok connection (IPC response null/undefined from main)');
        }
        return wssID; 
    } catch (error) {
        console.error('Error in TikTok WebSocket connection from source:', error);
        Toast.warning("TikTok WSS Error", `Connection Failed: ${error.message || 'Please try again.'}`);
        throw error; 
    }
}

// Simple modal functions for TikTok auth
function showModal(content) {
    // Remove any existing modal
    closeModal();
    
    const modal = document.createElement('div');
    modal.id = 'tiktok-auth-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
    `;
    modal.innerHTML = content;
    
    // Close on background click
    modal.addEventListener('click', function(e) {
        if (e.target === modal) {
            closeModal();
        }
    });
    
    document.body.appendChild(modal);
}

function closeModal() {
    const modal = document.getElementById('tiktok-auth-modal');
    if (modal) {
        modal.remove();
    }
}

function showTikTokSignInMenu(sourceId) {
    const source = stateManager.getSource(sourceId);
    if (!source) return;
    
    const isAuthenticated = source.tiktokSessionId ? true : false;
    
    let menuContent = `
        <div style="padding: 20px; background: #2a2a2a; border-radius: 8px;">
            <h3 style="margin-bottom: 15px;">TikTok Authentication</h3>
            ${isAuthenticated ? 
                `<p style="color: #4ade80; margin-bottom: 15px;">✓ Currently signed in</p>` : 
                `<p style="margin-bottom: 15px;">Sign in to TikTok for enhanced features:</p>
                <ul style="margin-bottom: 15px; margin-left: 20px;">
                    <li>Send chat messages</li>
                    <li>More stable connection</li>
                    <li>Access to all features</li>
                </ul>`
            }
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                ${!isAuthenticated ? `
                    <button onclick="tiktokSignIn('${sourceId}')" class="button" style="background: #6366f1;">
                        🌐 Sign in with Browser
                    </button>
                    <button onclick="tiktokManualSignIn('${sourceId}')" class="button" style="background: #6b7280;">
                        📝 Enter Cookies Manually
                    </button>
                ` : `
                    <button onclick="clearTikTokAuth('${sourceId}')" class="button" style="background: #ef4444;">
                        🗑️ Clear Authentication
                    </button>
                `}
                <button onclick="closeModal()" class="button" style="background: #374151;">
                    Cancel
                </button>
            </div>
        </div>
    `;
    
    showModal(menuContent);
}

function clearTikTokAuth(sourceId) {
    const source = stateManager.getSource(sourceId);
    if (source) {
        stateManager.updateSource(sourceId, {
            tiktokSessionId: null,
            tiktokTtTargetIdc: null
        });
        
        // Update UI
        const entry = document.querySelector(`[data-source-id="${sourceId}"]`);
        if (entry) {
            const signInBtn = entry.querySelector('[data-tiktok-signin]');
            if (signInBtn) {
                signInBtn.innerHTML = '🔑 TikTok Sign-in';
                signInBtn.classList.remove('authenticated');
            }
        }
        
        Toast.success("TikTok Sign-in", "Authentication cleared");
        closeModal();
    }
}

async function tiktokSignIn(sourceId) {
    closeModal();
    try {
        const result = await ipcRenderer.invoke('authenticateTikTok');
        if (result.success && result.credentials) {
            // Store credentials in the source
            const source = stateManager.getSource(sourceId);
            if (source) {
                stateManager.updateSource(sourceId, {
                    tiktokSessionId: result.credentials.sessionId,
                    tiktokTtTargetIdc: result.credentials.ttTargetIdc
                });
                Toast.success("TikTok Sign-in", "Successfully signed in to TikTok!");
                
                // Update UI to show authenticated status
                const entry = document.querySelector(`[data-source-id="${sourceId}"]`);
                if (entry) {
                    const signInBtn = entry.querySelector('[data-tiktok-signin]');
                    if (signInBtn) {
                        signInBtn.innerHTML = '✓ Signed In';
                        signInBtn.classList.add('authenticated');
                    }
                }
            }
        } else {
            Toast.error("TikTok Sign-in", result.error || "Sign-in failed");
        }
    } catch (error) {
        console.error('TikTok sign-in error:', error);
        Toast.error("TikTok Sign-in", error.message || "Sign-in failed");
    }
}

async function tiktokManualSignIn(sourceId) {
    closeModal();
    try {
        const result = await ipcRenderer.invoke('promptTikTokCookies');
        if (result.success && result.credentials) {
            // Store credentials in the source
            const source = stateManager.getSource(sourceId);
            if (source) {
                stateManager.updateSource(sourceId, {
                    tiktokSessionId: result.credentials.sessionId,
                    tiktokTtTargetIdc: result.credentials.ttTargetIdc
                });
                Toast.success("TikTok Sign-in", "Successfully added TikTok credentials!");
                
                // Update UI to show authenticated status
                const entry = document.querySelector(`[data-source-id="${sourceId}"]`);
                if (entry) {
                    const signInBtn = entry.querySelector('[data-tiktok-signin]');
                    if (signInBtn) {
                        signInBtn.innerHTML = '✓ Signed In';
                        signInBtn.classList.add('authenticated');
                    }
                }
            }
        }
    } catch (error) {
        console.error('TikTok manual sign-in error:', error);
        Toast.error("TikTok Sign-in", error.message || "Failed to add credentials");
    }
}

function cleanupTikTokConnection(entry, errorMessage = null) {
    if (!entry) return;
    const sourceId = entry.dataset.sourceId;
    if (!sourceId) return;

    if (errorMessage) {
        updateConnectionStatus(entry, 'error', errorMessage);
    } else {
        updateConnectionStatus(entry, 'stopped', 'Connection stopped.');
        setTimeout(()=> updateConnectionStatus(entry, 'clear'), 3000);
    }
}

function updateUIForActiveTikTokConnection(element) {
    if (element) updateConnectionStatus(element, 'connected');
}

function updateConnectionStatus(element, status, message = null) {
	if (!element) return;
	let statusElement = element.querySelector('.ws-status');
	if (!statusElement) { 
		statusElement = document.createElement('div');
		statusElement.className = 'ws-status';
		const controlPanel = element.querySelector('.control-panel');
        if (controlPanel) {
            element.insertBefore(statusElement, controlPanel.nextSibling); 
        } else { 
            element.appendChild(statusElement);
        }
	}
	statusElement.classList.remove('hidden', 'error', 'connecting', 'connected', 'retry', 'stopped');
    statusElement.style.display = 'inline-flex'; 

	switch (status) {
		case 'connecting':
			statusElement.classList.add('connecting');
			statusElement.innerHTML = '<i class="las la-sync fa-spin"></i> Connecting...';
			break;
		case 'connected':
			statusElement.classList.add('connected');
			statusElement.innerHTML = '<i class="las la-check-circle"></i> WebSocket Connected';
			break;
		case 'error':
			statusElement.classList.add('error');
			statusElement.innerHTML = `<i class="las la-exclamation-circle"></i> ${message || 'Connection error'}`;
			break;
		case 'retry': 
			statusElement.classList.add('retry'); 
			statusElement.innerHTML = `<i class="las la-sync fa-spin"></i> ${message || 'Retrying connection...'}`;
			break;
		case 'stopped':
			statusElement.classList.add('stopped');
            statusElement.innerHTML = `<i class="las la-hand-paper"></i> ${message || 'Connection stopped'}`;
			setTimeout(() => {
				if (statusElement.classList.contains('stopped')) statusElement.style.display = 'none';
			}, 5000);
			break;
		case 'clear':
		default:
			statusElement.style.display = 'none'; 
            statusElement.innerHTML = '';
			break;
	}
}


async function signin(ele, tabid = false) {
    // Debug logs removed - they show the parent window's UA, not the sign-in window's
    
    if (!ipcRenderer) { console.error('IPC not available for signin'); return; }

    const entry = ele.closest('.entry');
    if (!entry) { console.error('Could not find parent entry element for signin'); return; }

    const sourceId = entry.dataset.sourceId;
    const source = sourceId ? stateManager.getSource(sourceId) : null;
    console.log(`[SIGNIN DEBUG] Source ID: ${sourceId}, Source:`, source);
    if (!source && !entry.dataset.target) { 
         console.error('Cannot signin: no source data or target on element.'); return;
    }
    const targetPlatform = source ? source.target : entry.dataset.target;
    let urlForSignin = source ? source.url : entry.dataset.url; 

    let signinUrl = config?.[targetPlatform]?.signin?.url;
    if (!signinUrl && urlForSignin) {
        try {
            signinUrl = "https://" + getPrimaryDomain(urlForSignin);
        } catch { /* Use platform default */ }
    }
    if (!signinUrl) { 
        if (targetPlatform === 'youtube') signinUrl = 'https://youtube.com';
        else if (targetPlatform === 'twitch') signinUrl = 'https://www.twitch.tv';
        else { Toast.error("Sign-in Error", `No sign-in URL configured for ${targetPlatform}.`); return; }
    }

    let conf = config.global ? { ...config.global } : {};
    if (config.global?.signin) conf = { ...conf, ...config.global.signin };
    if (config[targetPlatform]) conf = { ...conf, ...config[targetPlatform] };
    if (config[targetPlatform]?.signin) conf = { ...conf, ...config[targetPlatform].signin };
    
    // Apply custom user agent if set
    if (source && source.userAgent && source.userAgent !== 'AUTO') {
        conf.userAgent = source.userAgent;
        console.log('[SignIn] Using custom user agent:', conf.userAgent);
    } else {
        console.log('[SignIn] Using AUTO user agent from config:', conf.userAgent);
    }
    
    console.log(`[SIGN-IN DEBUG] Platform: ${targetPlatform}, URL: ${signinUrl}, CustomSession: ${source ? (source.customSession || 'AUTO') : 'AUTO'}`);
    try {
        const response = ipcRenderer.sendSync('signIn', {
            url: signinUrl.trim(),
            muted: true, visible: true, source: false, tab: tabid,
            customSession: source ? (source.customSession || 'AUTO') : 'AUTO',
            config: conf, configs: config
        });
        console.log("Sign-in window created with ID:", response);
        if (response && ipcRenderer) { 
            ipcRenderer.once(`window-closed-${response}`, () => {
                Toast.info("Sign-in window closed.", "Checking if source needs refresh...");
                
                // Just call refreshWindow directly with the element
                refreshWindow(ele);
            });
        }
        return response; 
    } catch (err) {
        console.error('Signin failed:', err);
        Toast.error("Sign-in Error", `Could not open sign-in window: ${err.message}`);
        return false;
    }
}

function refreshActivatedWindow(ele) { 
    const entry = ele.closest('.entry');
    if (!entry) return;
    const sourceId = entry.dataset.sourceId;
    const source = sourceId ? stateManager.getSource(sourceId) : null;

    if (source && source.vid) { 
        refreshWindow(ele); 
    } else {
        Toast.info("Refresh Info", "Sign-in complete. Activate the source if it's not already running.");
    }
}

function processSettingsAndCreateSources() {
    console.log('[Startup] Processing settings and creating sources');
    cleanupYouTubeGroups(); 
    
    // Fix orphaned YouTube sources that should belong to groups
    const allSources = stateManager.getSources();
    allSources.forEach(source => {
        if (source.groupId && source.videoId && source.target && source.target.startsWith('youtube')) {
            const group = stateManager.getGroup(source.groupId);
            if (group && !group.streams.includes(source.id)) {
                console.log("Fixing orphaned YouTube source:", source.id, "adding to group:", source.groupId);
                group.streams.push(source.id);
                stateManager.persist();
            }
        }
    });

    const sourcesContainer = document.getElementById("sources");
    sourcesContainer.querySelectorAll(".entry:not(#sourceTemplate):not(#groupTemplate)").forEach(el => el.remove());

    const groups = stateManager.getGroups();
    groups.forEach(group => {
        if (!document.querySelector(`[data-group-id="${group.id}"]`)) {
            const groupElement = createGroupElement(group.id);
            if (groupElement) {
                sourcesContainer.appendChild(groupElement);
                if (group.autoActivate && (group.target === "youtube" || group.target === "youtubeshorts")) {
                    setTimeout(async () => {
                        console.log('Auto-activating YouTube group from processSettings:', group.username);
                        await handleYouTubeActivation(
                            group.username,
                            group.target === "youtubeshorts",
                            false, 
                            true,  
                            group.isChannel
                        );
                    }, 2500 + Math.random() * 1000);
                }
            }
        } else { 
            const groupElement = document.querySelector(`[data-group-id="${group.id}"]`);
            const streamsContainer = groupElement?.querySelector('.stream-group');
            if (streamsContainer) {
                console.log("Processing existing group in processSettings:", group.id, "streams:", group.streams);
                group.streams.forEach(sourceId => {
                    if (!streamsContainer.querySelector(`[data-source-id="${sourceId}"]`)) {
                        console.log("Creating source element for existing group stream in processSettings:", sourceId);
                        const sourceElement = createSourceElement(sourceId);
                        if (sourceElement) {
                            console.log("Appending to existing group in processSettings:", sourceId);
                            streamsContainer.appendChild(sourceElement);
                        } else {
                            console.error("Failed to create source element in processSettings:", sourceId);
                        }
                    }
                });
            }
        }
    });

    const standaloneSources = stateManager.getSources().filter(s => !s.groupId); 
    console.log(`[Startup] Found ${standaloneSources.length} standalone sources`);
    standaloneSources.forEach(source => {
         if (!document.querySelector(`[data-source-id="${source.id}"]`)) {
            console.log(`[Startup] Creating element for source ${source.id}: autoActivate=${source.autoActivate}`);
            const sourceElement = createSourceElement(source.id);
            if (sourceElement) {
                sourcesContainer.appendChild(sourceElement);
                if (source.autoActivate && !source.vid && !source.wssId) { 
                    setTimeout(async () => {
                        const activateButton = sourceElement.querySelector('[data-activatehtml]');
                        const currentSrcState = stateManager.getSource(source.id); 
                        if (activateButton && currentSrcState && !currentSrcState.vid && !currentSrcState.wssId) {
                            await createWindow(activateButton);
                        }
                    }, 2000 + Math.random() * 1000);
                }
            }
        }
    });
    manageWelcomePage();
}


function isVideoAlreadyAdded(videoId) {
    if (!videoId) return false;
    return stateManager.isVideoIdAdded(videoId);
}


function initializeFeatures() {
    const betaToggle = new BetaToggle(); 
	betaToggle.checkBetaAvailability();

    streamSelector = new YouTubeStreamSelector(); 
	youtubeStatusManager = new YouTubeStatusManager(); 
}

class BetaToggle {
	constructor() {
		this.container = null;
		this.betaVersion = null;
		this.mainVersion = null;
		this.cachedManifest = {}; 
	}
	async checkBetaAvailability() {
		try {
            const betaUrl = 'https://socialstream.ninja/beta/manifest.json';
			const mainUrl = 'https://socialstream.ninja/manifest.json';
			if (this.cachedManifest[betaUrl]) {
				this.betaVersion = this.cachedManifest[betaUrl].version;
			}
			if (this.cachedManifest[mainUrl]) {
				this.mainVersion = this.cachedManifest[mainUrl].version;
			}
			if (!this.betaVersion || !this.mainVersion) {
				const fetchPromises = [];
				if (!this.betaVersion) {
					fetchPromises.push(
						fetch(betaUrl)
							.then(response => response.json())
							.then(data => { this.cachedManifest[betaUrl] = data; this.betaVersion = data.version; })
                            .catch(e => console.warn("Failed to fetch beta manifest", e))
					);
				}
				if (!this.mainVersion) {
					fetchPromises.push(
						fetch(mainUrl)
							.then(response => response.json())
							.then(data => { this.cachedManifest[mainUrl] = data; this.mainVersion = data.version; })
                            .catch(e => console.warn("Failed to fetch main manifest", e))
					);
				}
				await Promise.all(fetchPromises);
			}

            if (this.betaVersion && this.mainVersion) {
    			this.createToggle();
            } else {
                console.warn("Could not fetch necessary version manifests to create Beta Toggle.");
            }
		} catch (error) {
			console.error('Error checking beta availability:', error);
		}
	}
	compareVersions(version1, version2) { 
        if (!version1 || !version2) return 0;
		const parts1 = version1.split('.').map(Number);
		const parts2 = version2.split('.').map(Number);
		for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
			const num1 = parts1[i] || 0;
			const num2 = parts2[i] || 0;
			if (num1 > num2) return 1;
			if (num2 > num1) return -1;
		}
		return 0;
    }

	createToggle() {
        if (document.querySelector('.beta-toggle')) return;
        const currentBetaMode = stateManager.state.global.betaMode;

		this.container = document.createElement('div');
		this.container.className = 'beta-toggle';
        const versions = document.createElement('div');
		versions.className = 'beta-toggle-versions';
		versions.innerHTML = `
			<div>Production: v${this.mainVersion || 'N/A'}</div>
			<div>Beta: v${this.betaVersion || 'N/A'}</div>
		`;

		const toggleSwitchContainer = document.createElement('div');
        toggleSwitchContainer.className = 'beta-toggle-switch-container';
		const toggle = document.createElement('div');
		toggle.className = `beta-toggle-switch${currentBetaMode ? ' active' : ''}`;
		toggle.addEventListener('click', () => this.handleToggle());
        toggleSwitchContainer.appendChild(toggle);

		const label = document.createElement('span');
		label.className = 'beta-toggle-label';
		label.textContent = currentBetaMode ? 'Beta Active' : 'Production Active';

		this.container.appendChild(versions);
		this.container.appendChild(toggleSwitchContainer);
		this.container.appendChild(label);

        const sourcesDiv = document.getElementById("sources");
        if (sourcesDiv && sourcesDiv.firstChild) {
    		sourcesDiv.insertBefore(this.container, sourcesDiv.firstChild);
        } else if (sourcesDiv) {
            sourcesDiv.appendChild(this.container);
        }
	}
	async handleToggle() {
		const newBetaState = !stateManager.state.global.betaMode;
		stateManager.updateGlobal({ betaMode: newBetaState }); 
        isBetaMode = newBetaState; 

		const toggle = this.container.querySelector('.beta-toggle-switch');
		toggle.classList.toggle('active', newBetaState);
		const label = this.container.querySelector('.beta-toggle-label');
		label.textContent = newBetaState ? 'Beta Active' : 'Production Active';
        
        Toast.info("Mode Changed", `Switched to ${newBetaState ? 'Beta' : 'Production'} mode. Restart app or refresh page for full effect if issues arise.`);

		if (!devmode && !sourcemode) {
            console.log(`Beta mode toggled. Now: ${newBetaState}. Re-initializing parts or consider app reload.`);
            await initializeApplication(); 
		} else {
            console.log("Beta mode toggled, but dev/sourcemode active.");
        }
	}
}

async function initializeConfig() { 
    configReady = false;
	try {
		const os = getOperatingSystem();
		const configFileName = getConfigFileName(os);
		const currentBetaMode = stateManager.initialized ? stateManager.state.global.betaMode : (localStorage.getItem('betaMode') === 'true'); 

		const configUrl =
			sourcemode ? `${sourcemode}/settings/${configFileName}` :
			devmode ? `file:///C:/Users/steve/Code/social_stream/settings/${configFileName}` :
			currentBetaMode ? `https://socialstream.ninja/beta/settings/${configFileName}` :
			`https://socialstream.ninja/settings/${configFileName}`;
		
		const response = await fetch(configUrl.trim());
		const data = await response.json();
		if (data) {
			config = data;
			localStorage.setItem('config', JSON.stringify(data));
		}
	} catch (e) {
        Toast.error("Error", 'Failed to load the user-agent config file.');
		console.error('Failed to load remote config:', e);
		const storedConfigTemp = localStorage.getItem('config'); 
		if (storedConfigTemp) {
			try {
				const parsedConfig = JSON.parse(storedConfigTemp);
				if (!parsedConfig || Object.keys(parsedConfig).length === 0) {
					console.error('Parsed stored config is empty, using default.');
					config = getDefaultConfig();
				} else {
					config = parsedConfig;
				}
			} catch (parseError) {
				console.error('Failed to parse stored config, using default:', parseError);
				config = getDefaultConfig();
			}
		} else { 
			config = getDefaultConfig();
		}
	}
	configReady = true;
	return config;
}

// DOMContentLoaded Listener
document.addEventListener('DOMContentLoaded', async function() {
    await stateManager.init();
    
    // Clean up stale window IDs on startup
    const sources = stateManager.getSources();
    for (const source of sources) {
        // Set default connection mode for TikTok sources if not set
        if (source.target === 'tiktok' && !source.connectionMode) {
            console.log(`Setting default tiktok-websocket mode for ${source.id} on startup`);
            stateManager.updateSource(source.id, { connectionMode: 'tiktok-websocket' });
        }
        
        // Check regular windows
        if (source.vid && ipcRenderer) {
            const windowExists = await ipcRenderer.invoke('checkWindowExists', { vid: source.vid });
            if (!windowExists) {
                stateManager.updateSource(source.id, { vid: null, status: 'inactive' });
            }
        }
        
        // Clean up websocket IDs on startup - websocket connections don't persist across app restarts
        if (source.wssId) {
            console.log(`Clearing stale wssId ${source.wssId} for ${source.id} on startup`);
            stateManager.updateSource(source.id, { vid: null, wssId: null, status: 'inactive' });
        }
        
        // Clear video IDs and chat IDs for username-based Rumble sources
        if (source.target === 'rumble' && source.username && (source.videoId || source.chatId)) {
            stateManager.updateSource(source.id, { videoId: null, chatId: null, url: null });
        }
    }
    
    // Listen for source updates to keep UI in sync
    stateManager.on('sourceUpdated', ({ sourceId, updates }) => {
        console.log(`Source ${sourceId} updated:`, updates);
        const sourceElement = document.querySelector(`[data-source-id="${sourceId}"]`);
        if (sourceElement) {
            const source = stateManager.getSource(sourceId);
            if (source) {
                // Update mute button state if mute state changed
                if ('isMuted' in updates) {
                    const muteButton = sourceElement.querySelector('[data-togglemute]');
                    if (muteButton) {
                        muteButton.classList.toggle('active', source.isMuted);
                        console.log(`Updated mute button UI for ${sourceId}: ${source.isMuted}`);
                    }
                }
                // Update visibility button state if visibility changed
                if ('isVisible' in updates) {
                    const visibilityButton = sourceElement.querySelector('[data-togglehtml]');
                    if (visibilityButton) {
                        visibilityButton.classList.toggle('active', !source.isVisible);
                    }
                }
            }
        }
    });
    
    // Start auto-checking for YouTube groups and Rumble sources with auto-activate enabled
    setTimeout(() => {
        // Verify fetchYoutube is available
        if (typeof fetchYoutube !== 'function') {
            console.error("Warning: fetchYoutube function not available. YouTube fallback scraping will not work.");
            console.error("Make sure youtube.js is properly loaded.");
        } else {
            console.log("fetchYoutube function is available for fallback.");
        }
        
        // Check YouTube groups
        const groups = stateManager.getGroups();
        groups.forEach(group => {
            if (group.autoActivate && (group.target === "youtube" || group.target === "youtubeshorts")) {
                console.log(`Starting auto-check for YouTube group on startup: ${group.username}`);
                startYouTubeGroupAutoCheck(group.id);
            }
        });
        
        // Check Rumble sources and update TikTok UI
        const sources = stateManager.getSources();
        sources.forEach(source => {
            // Update TikTok sources to show correct mode
            if (source.target === 'tiktok') {
                const sourceElement = document.querySelector(`[data-source-id="${source.id}"]`);
                if (sourceElement) {
                    const mode = source.connectionMode || 'tiktok-websocket';
                    
                    // Update button text
                    updateSourceUIAfterModeChange(sourceElement, mode, false);
                    
                    // Update mode selector to show active state
                    const modeOptions = sourceElement.querySelectorAll('.mode-option');
                    modeOptions.forEach(opt => {
                        opt.classList.remove('active');
                        if (opt.dataset.mode === mode) {
                            opt.classList.add('active');
                        }
                    });
                }
            }
            
            // Only auto-check username-based Rumble sources
            if (source.autoActivate && source.target === 'rumble' && source.username && source.status !== 'active') {
                console.log(`Starting auto-check for Rumble source on startup: ${source.username}`);
                startRumbleAutoCheck(source.id);
            }
        });
    }, 2000); // Small delay to ensure UI is ready 

    // Check for pending import from session import
    const pendingImport = localStorage.getItem('pendingImport');
    if (pendingImport) {
        try {
            const importData = JSON.parse(pendingImport);
            // Restore all the localStorage data from the import
            for (const [key, value] of Object.entries(importData)) {
                if (value !== null) {
                    localStorage.setItem(key, value);
                }
            }
            localStorage.removeItem('pendingImport');
            // Re-initialize state manager with imported data
            await stateManager.init();
            Toast.success('Import Complete', 'Session data has been imported successfully');
        } catch (e) {
            console.error('Error applying pending import:', e);
            Toast.error('Import Error', 'Failed to apply imported session data');
            localStorage.removeItem('pendingImport');
        }
    }

    isBetaMode = stateManager.state.global.betaMode;
    localStorage.setItem('betaMode', isBetaMode.toString());
    localStorage.setItem('youtubeAutoAdd', stateManager.state.global.youtubeAutoAdd.toString());
    localStorage.setItem('youtubeAutoCleanup', stateManager.state.global.youtubeAutoCleanup.toString());
    localStorage.setItem('youtubeCheckInterval', stateManager.state.global.youtubeCheckInterval.toString());

    /* Modified sourceAdded listener */
    stateManager.on('sourceAdded', ({ source }) => {
        console.log("sourceAdded event:", source.id, "videoId:", source.videoId, "groupId:", source.groupId);
        let element = document.querySelector(`[data-source-id="${source.id}"]`);
        if (element) {
            console.warn(`sourceAdded listener: Element for source ${source.id} already exists. Updating UI.`);
            updateSourceUI(element, source);
            // Ensure it's in the correct parent if misplaced (e.g., if group DOM wasn't ready)
            const correctParentSelector = source.groupId ? `[data-group-id="${source.groupId}"] .stream-group` : '#sources';
            const correctParent = document.querySelector(correctParentSelector);
            if (correctParent && element.parentElement !== correctParent && !(element.parentElement.id === 'sources' && !source.groupId) ) {
                 console.log(`Moving ${source.id} to correct parent: ${correctParentSelector}`);
                 correctParent.appendChild(element);
            }
            return;
        }

        element = createSourceElement(source.id); 
        if (!element) {
            console.error(`sourceAdded listener: Failed to create element for source ${source.id}`);
            return;
        }

        if (!source.groupId) {
            document.getElementById("sources").appendChild(element);
        } else {
            const groupElement = document.querySelector(`[data-group-id="${source.groupId}"]`);
            if (groupElement) {
                const streamsContainer = groupElement.querySelector('.stream-group');
                if (streamsContainer) {
                    streamsContainer.appendChild(element);
                } else {
                    console.warn(`sourceAdded listener: '.stream-group' not found in group ${source.groupId}. Appending source ${source.id} to group header as fallback.`);
                    groupElement.appendChild(element); 
                }
            } else {
                console.warn(`sourceAdded listener: Group element for groupId ${source.groupId} not found. Appending source ${source.id} to main 'sources' list temporarily.`);
                document.getElementById("sources").appendChild(element);
            }
        }
        manageWelcomePage();
    });


    stateManager.on('sourceUpdated', ({ sourceId, updates, oldState }) => {
        const element = document.querySelector(`[data-source-id="${sourceId}"]`);
        const source = stateManager.getSource(sourceId);
        if (element && source) {
            updateSourceUI(element, source);
        }
        
        if ('groupId' in updates) {
            const currentElement = document.querySelector(`[data-source-id="${sourceId}"]`); 
            if (!currentElement) return; 

            if (oldState.groupId && oldState.groupId !== updates.groupId) {
                const oldGroupStreamsContainer = document.querySelector(`[data-group-id="${oldState.groupId}"] .stream-group`);
                const elInOldGroup = oldGroupStreamsContainer?.querySelector(`[data-source-id="${sourceId}"]`);
                elInOldGroup?.remove();
            }
            
            if (updates.groupId) {
                 const newGroupEl = document.querySelector(`[data-group-id="${updates.groupId}"]`);
                 const streamsContainer = newGroupEl?.querySelector('.stream-group');
                 if (streamsContainer && !streamsContainer.querySelector(`[data-source-id="${sourceId}"]`)) {
                    streamsContainer.appendChild(currentElement); 
                 } else if (!streamsContainer && newGroupEl && !newGroupEl.querySelector(`[data-source-id="${sourceId}"]`)) {
                    newGroupEl.appendChild(currentElement); 
                 }
            } else if (!updates.groupId && currentElement.parentElement?.closest?.('[data-is-group-header="true"]')) { 
                 if (currentElement.parentElement.id !== 'sources') {
                    document.getElementById("sources").appendChild(currentElement); 
                 }
            }
        }
    });

    stateManager.on('sourceRemoved', ({ sourceId, source }) => {
        const element = document.querySelector(`[data-source-id="${sourceId}"]`);
        element?.remove();
        manageWelcomePage();
    });

    /* Modified groupAdded listener */
    stateManager.on('groupAdded', ({ group }) => {
        let groupElement = document.querySelector(`[data-group-id="${group.id}"]`);
        if (groupElement) {
            console.warn(`groupAdded listener: Group element for ID ${group.id} already exists. Updating UI and checking children.`);
            updateGroupUI(groupElement, group); 
            const streamsContainer = groupElement.querySelector('.stream-group');
            if (streamsContainer) {
                group.streams.forEach(sourceId => {
                    if (!streamsContainer.querySelector(`[data-source-id="${sourceId}"]`)) {
                        const tempSourceElement = document.getElementById("sources").querySelector(`:scope > [data-source-id="${sourceId}"]`);
                        if (tempSourceElement) {
                            streamsContainer.appendChild(tempSourceElement); 
                        } else {
                            const sourceElement = createSourceElement(sourceId); 
                            if (sourceElement) streamsContainer.appendChild(sourceElement);
                        }
                    }
                });
            }
            return;
        }

        groupElement = createGroupElement(group.id); 
        if (groupElement) {
            document.getElementById("sources").appendChild(groupElement);
            const streamsContainer = groupElement.querySelector('.stream-group');
            if (streamsContainer) {
                group.streams.forEach(sourceId => {
                    const sourceState = stateManager.getSource(sourceId);
                    if (sourceState?.groupId === group.id) { 
                        const tempSourceElement = document.getElementById("sources").querySelector(`:scope > [data-source-id="${sourceId}"]`);
                        if (tempSourceElement) { 
                            if (!streamsContainer.querySelector(`[data-source-id="${sourceId}"]`)) { 
                                streamsContainer.appendChild(tempSourceElement); 
                            }
                        }
                    }
                });
            }
        }
        manageWelcomePage();
    });
    
    stateManager.on('groupUpdated', ({ groupId, updates }) => {
        const element = document.querySelector(`[data-group-id="${groupId}"]`);
        const group = stateManager.getGroup(groupId);
        if (element && group) {
            updateGroupUI(element, group);
        }
    });
    
    stateManager.on('groupRemoved', ({ groupId, group }) => {
        const element = document.querySelector(`[data-group-id="${groupId}"]`);
        element?.remove();
        manageWelcomePage();
    });
    
    stateManager.on('globalUpdated', ({ updates }) => {
        if ('betaMode' in updates) {
            isBetaMode = updates.betaMode;
             console.log("Global betaMode updated, re-initializing application for full effect.");
             initializeApplication(); 
        }
        if (youtubeStatusManager && (
            'youtubeAutoAdd' in updates || 
            'youtubeAutoCleanup' in updates || 
            'youtubeCheckInterval' in updates
        )) {
            youtubeStatusManager.settingsChanged(updates); 
        }
    });


    initializeFeatures(); 
	await checkForUpdates();

	let ready = await initializeApplication();
	if (ready) {
		processSettingsAndCreateSources(); 
	} else {
        console.error("Application initialization failed. Some features may be unavailable.");
        Toast.error("Initialization Error", "App could not start correctly. Please check console or try restarting.");
    }

	if (!window.streamSelector) {
		window.streamSelector = new YouTubeStreamSelector();
	}

	const navigationLinks = document.querySelectorAll('#main-navigation a');
    const frame1 = document.getElementById('frame1');
	const frame2 = document.getElementById('frame2');
	const frame3 = document.getElementById('frame3');

	function switchToPage(pageId) { 
        navigationLinks.forEach(link => {
			link.classList.toggle('active', link.dataset.page === pageId);
		});

        document.getElementById('streams-page')?.style.setProperty('display', 'none', 'important');
        document.getElementById('dashboard-page')?.style.setProperty('display', 'none', 'important');
        //document.getElementById('link-overlay-page')?.style.setProperty('display', 'none', 'important');
        document.getElementById('vdo-ninja-page')?.style.setProperty('display', 'none', 'important');
       // if (frame1) frame1.style.setProperty('display', 'none', 'important');
        if (frame2) frame2.style.setProperty('display', 'none', 'important');
        if (frame3) frame3.style.setProperty('display', 'none', 'important');


        const streamsPage = document.getElementById('streams-page');
        const dashboardPage = document.getElementById('dashboard-page');
        //const linkOverlayPage = document.getElementById('link-overlay-page');
        const vdoNinjaPage = document.getElementById('vdo-ninja-page');

		if (pageId === 'dashboard' || pageId === 'event-flow-editor') {
			if (dashboardPage) dashboardPage.style.display = 'block'; 
			if (frame2) {
				frame2.style.display = 'block'; 
                const viewFunction = pageId === 'dashboard' ? 'showDashboardView' : 'showEditorView';
                // Use postMessage for cross-origin communication
                const sendViewMessage = () => {
                    try {
                        frame2.contentWindow.postMessage({ action: viewFunction }, '*');
                    } catch (err) {
                        console.error('Failed to communicate with iframe:', err);
                    }
                };
                
                // Check if iframe is already loaded
                if (frame2.contentDocument && frame2.contentDocument.readyState === 'complete') {
                    sendViewMessage();
                } else {
                    // Wait for iframe to load
                    frame2.addEventListener('load', sendViewMessage, { once: true });
                    // Also try sending after a delay in case the load event already fired
                    setTimeout(sendViewMessage, 500);
                }
			}
		} else if (pageId === 'link-overlay') {
			//if (linkOverlayPage) linkOverlayPage.style.display = 'block';
		//	if (frame1) frame1.style.display = 'block';
		} else if (pageId === 'streams') {
			if (streamsPage) streamsPage.style.display = 'block';
		} else if (pageId === 'vdo-ninja') {
			if (vdoNinjaPage) vdoNinjaPage.style.display = 'block';
			if (frame3) frame3.style.display = 'block';
		}

        if ((pageId === 'dashboard' || pageId === 'event-flow-editor') && frame2 && (!frame2.src || frame2.src === "about:blank")) {
			setupIframeSource(); 
		} else if (pageId === 'link-overlay' && frame1 && (!frame1.src || frame1.src === "about:blank")) {
			let popupSrc = "";
            if (sourcemode) {
                popupSrc = `${sourcemode}popup.html?sourcemode=${encodeURIComponent(sourcemode)}&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
                if (devmode) popupSrc += "&devmode";
            } else if (devmode) {
                popupSrc = `file:///C:/Users/steve/Code/social_stream/popup.html?devmode&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
            } else {
                const domain = isBetaMode ? 'https://socialstream.ninja/beta' : 'https://socialstream.ninja';
                popupSrc = `${domain}/popup.html?v=2&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
            }
			frame1.src = popupSrc;
            frame1.classList.add('loading');
		} else if (pageId === 'vdo-ninja' && frame3 && (!frame3.src || frame3.src === "about:blank")) {
			let vdoSrc = "";
            if (sourcemode) {
                vdoSrc = `${sourcemode}vdo.html?sourcemode=${encodeURIComponent(sourcemode)}&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
                 if (devmode) vdoSrc += "&devmode";
            } else if (devmode) {
                vdoSrc = `file:///C:/Users/steve/Code/social_stream/vdo.html?devmode&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
            } else {
                const domain = isBetaMode ? 'https://socialstream.ninja/beta' : 'https://socialstream.ninja';
    			vdoSrc = `${domain}/vdo.html?v=2&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
            }
			frame3.src = vdoSrc;
            frame3.classList.add('loading');
		}
        stateManager.updateGlobal({ currentPage: pageId });
    }

	navigationLinks.forEach(link => {
		link.addEventListener('click', function(event) {
			event.preventDefault();
			const pageId = this.dataset.page;
			switchToPage(pageId);
		});
	});

    const initialPage = stateManager.state.global.currentPage || 'streams';
	switchToPage(initialPage); 

    if (ipcRenderer) {
        ipcRenderer.on('fromMainToIndex', (event, ...args) => { 
            log("FROM MAIN TO INDEX", args[0]);
            if (args[0] == "serverStarted") {
                console.log("serverStarted");
                localServer = "&localserver";
                setupIframeSource(); 
            } else if (args[0] == "serverStopped") {
                console.log("serverStopped");
                localServer = "";
                setupIframeSource(); 
            }
            const currentFrame1Src = document.getElementById("frame1")?.src;
            let expectedFrame1Src = "";
             if (sourcemode) {
                expectedFrame1Src = `${sourcemode}popup.html?sourcemode=${encodeURIComponent(sourcemode)}&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
                if (devmode) expectedFrame1Src += "&devmode";
            } else if (devmode) {
                expectedFrame1Src = `file:///C:/Users/steve/Code/social_stream/popup.html?devmode&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
            } else {
                const domain = isBetaMode ? 'https://socialstream.ninja/beta' : 'https://socialstream.ninja';
                expectedFrame1Src = `${domain}/popup.html?v=2&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
            }
            if (document.getElementById("frame1") && currentFrame1Src !== expectedFrame1Src) {
                 document.getElementById("frame1").src = expectedFrame1Src;
            }
        });

        ipcRenderer.on(`window-hidden`, (event, ...args) => {
            let tabId = args[0]?.tabID;
            if (tabId) {
                const sourceToUpdate = stateManager.getSources({ vid: tabId })[0];
                if (sourceToUpdate) {
                    stateManager.updateSource(sourceToUpdate.id, { isVisible: false });
                }
            }
        });
        
        ipcRenderer.on(`window-shown`, (event, ...args) => { 
            let tabId = args[0]?.tabID;
            if (tabId) {
                const sourceToUpdate = stateManager.getSources({ vid: tabId })[0];
                if (sourceToUpdate) {
                    stateManager.updateSource(sourceToUpdate.id, { isVisible: true });
                }
            }
        });


        ipcRenderer.on('tiktokConnectionStatus', (event, data) => {
            if (!data || !data.wssID) return;
            const sourceToUpdate = stateManager.getSources({ wssId: data.wssID })[0];
            if (!sourceToUpdate) return;

            const entryElement = document.querySelector(`[data-source-id="${sourceToUpdate.id}"]`);

            switch (data.status) {
                case 'connected':
                    stateManager.updateSource(sourceToUpdate.id, { status: 'active' }); 
                    if (entryElement) updateConnectionStatus(entryElement, 'connected');
                    break;
                case 'disconnected': 
                    stateManager.updateSource(sourceToUpdate.id, { status: 'error', error: data.error || 'Connection lost.', vid: null, wssId: null });
                    if (entryElement) updateConnectionStatus(entryElement, 'error', data.error || 'Connection lost. Will attempt to reconnect if configured.');
                    break;
                case 'error':
                    stateManager.updateSource(sourceToUpdate.id, { status: 'error', error: data.error || 'Connection error' });
                     if (entryElement) updateConnectionStatus(entryElement, 'error', data.error || 'Connection error');
                    break;
                case 'failed': 
                case 'fatal_error':
                    stateManager.updateSource(sourceToUpdate.id, { status: 'error', error: data.error || 'Connection failed', vid: null, wssId: null, connectionMode: 'classic' }); 
                     if (entryElement) updateConnectionStatus(entryElement, 'error', data.error || 'Connection failed');
                    break;
                case 'reconnecting':
                    stateManager.updateSource(sourceToUpdate.id, { status: 'activating' }); 
                     if (entryElement) updateConnectionStatus(entryElement, 'retry', `Retrying ${data.attempt || '?'}/${data.maxAttempts || '?'}`);
                    break;
                case 'stopped_by_user': 
                    stateManager.updateSource(sourceToUpdate.id, { status: 'inactive', vid:null, wssId:null });
                    if (entryElement) updateConnectionStatus(entryElement, 'stopped', 'Connection stopped by user.');
                    break;
            }
        });
    } 
});

console.log('[Electron] Current user agent:', navigator.userAgent);
console.log('[Electron] Window.electron exists?', !!window.electron);
console.log('[Electron] Process exists?', typeof process !== 'undefined');

// Check multiple ways to detect Electron (now that we hide it from UA)
const isElectron = (navigator.userAgent.toLowerCase().indexOf('electron/') > -1) || 
                   (typeof process !== 'undefined' && process.versions && process.versions.electron) ||
                   (window && window.process && window.process.type) ||
                   (window.electron && window.electron.ipcRenderer) || // Check for our preload exposure
                   (typeof require !== 'undefined'); // Node integration check

if (isElectron || window.electron) {
	console.log('[Electron] Detected Electron environment');
	try {
		if (!ipcRenderer) {
			// First try window.electron (from contextBridge in preload)
			if (window.electron && window.electron.ipcRenderer) {
				console.log('[Electron] Using ipcRenderer from contextBridge');
				ipcRenderer = window.electron.ipcRenderer;
			} 
			// Then try require (only works if nodeIntegration is enabled)
			else if (typeof require !== 'undefined') {
				console.log('[Electron] Attempting to require electron.ipcRenderer');
				ipcRenderer = require('electron').ipcRenderer;
			} else {
				console.log('[Electron] No access to ipcRenderer - nodeIntegration disabled and no contextBridge');
			}
			console.log('[Electron] Successfully loaded ipcRenderer:', !!ipcRenderer);
		}
		if (ipcRenderer) { 
            window.prompt = function(title, val, message = "") {
				log("window.prompt");
                let options = {};
                if (typeof title === 'object' && title !== null) {
                    options = title;
                } else { 
                    options.title = title;
                    options.message = message || val || ""; 
                    if (typeof val !== 'undefined' && message === "") options.value = val; 
                }
				return ipcRenderer.sendSync('prompt', options);
			};
			window.alert = function(title, val) { 
				log("window.alert");
				return ipcRenderer.send('alert', { 
					title: title, 
					message: val || title 
				});
			};
        }
    } catch(e) { 
        console.error("[Electron] IPC setup failed:", e);
        console.error("[Electron] This usually means nodeIntegration is disabled");
    }
}

var sourceTemplate = document.getElementById("sourceTemplate");
var groupTemplate = document.getElementById("groupTemplate"); 
var youtubeStatusManager = null;
var streamSelector = null;
var cachedManifest = {}; 
var iframes = document.querySelectorAll('iframe');
Array.prototype.forEach.call(iframes, function(iframe) {
	iframe.onload = function() { this.classList.remove('loading'); };
});
const basePath = window.location.href.split('index.html')[0];
function sleep(ms) { 
    return new Promise((resolve) => { setTimeout(resolve, ms); });
}

async function loadManifest() {
	const manifestUrl = getManifestUrl(); 
	try {
		const response = await fetch(manifestUrl);
        if (!response.ok) {
            throw new Error(`Manifest fetch failed: ${response.status} ${response.statusText}`);
        }
		const data = await response.json();
		if (data) {
			cachedManifest[manifestUrl] = data; 
			log("Fetched and cached remote manifest", data.version);
			localStorage.setItem('cachedManifest', JSON.stringify(data)); 
			return data;
		}
	} catch (e) {
		console.error('Error loading manifest from network:', e, manifestUrl);
		const storedManifest = localStorage.getItem('cachedManifest');
		if (storedManifest) {
			try {
				const parsedManifest = JSON.parse(storedManifest);
                const tempManifestUrl = parsedManifest.url; 
                if (tempManifestUrl === manifestUrl || !tempManifestUrl) { 
    				log("Using cached manifest from local storage.", parsedManifest.version);
	    			return parsedManifest;
                } else {
                    console.warn("Cached manifest URL does not match current mode's expected URL. Discarding old cache.");
                }
			} catch (parseError) {
				console.error('Error parsing cached manifest:', parseError);
			}
		}
	}
	return null; 
}
function getManifestUrl() { 
	if (sourcemode) return sourcemode + "manifest.json";
	if (devmode) return "file:///C:/Users/steve/Code/social_stream/manifest.json";
	if (isBetaMode) return "https://socialstream.ninja/beta/manifest.json";
	return "https://socialstream.ninja/manifest.json";
}
async function initializeApplication() {
	let newconfig = await initializeConfig(); 
	if (!newconfig) {
		console.error("Failed to initialize configuration.");
        Toast.error("Config Error", "Critical configuration failed to load.");
		return false;
	}
	config = newconfig;
	setupIframeSource(); 

	let loadedManifest = await loadManifest();
	if (!loadedManifest) {
		Toast.warning("Manifest Warning", "Failed to load remote manifest. Using cached version if available.");
        const cached = localStorage.getItem('cachedManifest'); 
        try {
            if (cached) manifest = JSON.parse(cached);
            else manifest = { content_scripts: [] };
            if (!manifest.content_scripts) manifest.content_scripts = [];
        } catch { manifest = { content_scripts: [] }; }
	} else {
    	manifest = loadedManifest;
    }
	console.log(manifest)
	console.log(config);
	return true;
}
function setupIframeSource() { 
	const frame2 = document.getElementById("frame2");
    if (!frame2) return;
	let iframesrc = "";
	// Get the language code for the URL
	const langCode = currentLanguage === 'pt-BR' ? 'pt' : currentLanguage;
	const langParam = `&ln=${langCode}`;
	
	// Check if we should show the editor view initially
	const viewParam = window.initialEditorView ? '&view=editor' : '';
	
	if (sourcemode) {
		 if (devmode) {
			document.getElementById("sources")?.classList.add("dev");
			iframesrc = `${sourcemode}background.html?sourcemode=${encodeURIComponent(sourcemode)}&devmode&ssapp=2${localServer}${langParam}${viewParam}`;
		 } else {
			iframesrc = `${sourcemode}background.html?sourcemode=${encodeURIComponent(sourcemode)}&ssapp=2${localServer}${langParam}${viewParam}`;
		}
	} else if (devmode) {
		document.getElementById("sources")?.classList.add("dev");
		iframesrc = `file:///C:/Users/steve/Code/social_stream/background.html?devmode&ssapp=2${localServer}${langParam}${viewParam}`;
	} else if (isBetaMode) {
		iframesrc = `https://socialstream.ninja/beta/background.html?v=2&ssapp=2${localServer}${langParam}${viewParam}`;
	} else {
		iframesrc = `https://socialstream.ninja/background.html?v=2&ssapp=2${localServer}${langParam}${viewParam}`;
	}

	if (!frame2.src || (iframesrc !== frame2.src)) {
		frame2.src = iframesrc;
        frame2.classList.add('loading');
	}
}
async function checkForUpdates() { 
    try {
		const response = await fetch('https://api.github.com/repos/steveseguin/social_stream/releases');
		const data = await response.json();
		// Find the latest non-prerelease version
		const latestRelease = data.find(release => !release.prerelease);
		if (latestRelease?.tag_name && ipcRenderer) {
			const currentVersion = await ipcRenderer.sendSync('getVersion'); 
			if (currentVersion && compareVersions(currentVersion, latestRelease.tag_name) === -1) { 
				const newver = document.getElementById("newver");
                if (newver) { 
    				newver.classList.remove("hidden");
	    			document.getElementById("downloadlink").href = `https://github.com/steveseguin/social_stream/releases/tag/${latestRelease.tag_name}`;
		    		newver.innerHTML = `<h1>NEW VERSION AVAILABLE</h1> <a id="downloadlink" href="https://github.com/steveseguin/social_stream/releases/tag/${latestRelease.tag_name}" target="_blank">Download new version here</a> <b>v${latestRelease.tag_name}</b> (installed: v${currentVersion})`;
                }
			}
		}
	} catch (e) {
		console.error('Error checking for updates:', e);
	}
}

// Session Management Functions
async function loadSessions() {
	try {
		const { sessions, currentSession } = await ipcRenderer.invoke('getSessions');
		
		// Update current session display
		const currentSessionElement = document.getElementById('current-session-name');
		if (currentSessionElement && sessions[currentSession]) {
			currentSessionElement.textContent = sessions[currentSession].name;
		}
		
		// Populate sessions list
		const container = document.getElementById('sessions-list-container');
		if (!container) return;
		
		container.innerHTML = '';
		
		Object.entries(sessions).forEach(([id, session]) => {
			const sessionEl = document.createElement('div');
			sessionEl.className = 'session-item';
			if (id === currentSession) {
				sessionEl.classList.add('current');
			}
			
			sessionEl.innerHTML = `
				<div class="session-info">
					<h4 class="session-name">${session.name}</h4>
					${session.description ? `<p class="session-description">${session.description}</p>` : ''}
					<span class="session-date">Created: ${new Date(session.created).toLocaleDateString()}</span>
				</div>
				<div class="session-actions">
					${id !== currentSession ? `<button onclick="switchToSession('${id}')" class="switch-btn"><i class="las la-sign-in-alt"></i> Switch</button>` : '<span class="active-label">Active</span>'}
					${id !== 'default' ? `
						<button onclick="renameSession('${id}')" class="rename-btn"><i class="las la-edit"></i></button>
						<button onclick="deleteSession('${id}')" class="delete-btn"><i class="las la-trash"></i></button>
					` : '<span class="default-label">Original Data</span>'}
				</div>
			`;
			
			container.appendChild(sessionEl);
		});
	} catch (e) {
		console.error('Error loading sessions:', e);
	}
}

async function createNewSession() {
	const name = prompt('Enter a name for the new session:');
	if (!name) return;
	
	const description = prompt('Enter a description (optional):', 'A fresh start with no sources or settings');
	
	try {
		const result = await ipcRenderer.invoke('createSession', { name, description });
		if (result.success) {
			const switchNow = confirm('Session created! Do you want to switch to it now?\n\nNote: This will restart the application.');
			if (switchNow) {
				await switchToSession(result.sessionId);
			} else {
				loadSessions();
			}
		}
	} catch (e) {
		console.error('Error creating session:', e);
		alert('Failed to create session');
	}
}

async function switchToSession(sessionId) {
	const confirmSwitch = confirm('Switching sessions will restart the application. Continue?');
	if (!confirmSwitch) return;
	
	try {
		await ipcRenderer.invoke('switchSession', sessionId);
	} catch (e) {
		console.error('Error switching session:', e);
		alert('Failed to switch session');
	}
}

async function deleteSession(sessionId) {
	const confirmDelete = confirm('Are you sure you want to delete this session? This cannot be undone.');
	if (!confirmDelete) return;
	
	try {
		const result = await ipcRenderer.invoke('deleteSession', sessionId);
		if (result.success) {
			loadSessions();
		} else {
			alert(result.message || 'Failed to delete session');
		}
	} catch (e) {
		console.error('Error deleting session:', e);
		alert('Failed to delete session');
	}
}

async function renameSession(sessionId) {
	const currentName = document.querySelector(`[onclick="renameSession('${sessionId}')"]`)
		?.closest('.session-item')?.querySelector('.session-name')?.textContent;
	
	const newName = prompt('Enter new name:', currentName);
	if (!newName || newName === currentName) return;
	
	try {
		const result = await ipcRenderer.invoke('renameSession', sessionId, newName);
		if (result.success) {
			loadSessions();
		} else {
			alert(result.message || 'Failed to rename session');
		}
	} catch (e) {
		console.error('Error renaming session:', e);
		alert('Failed to rename session');
	}
}

async function exportCurrentSession() {
	try {
		// Show loading indicator
		Toast.info('Exporting...', 'Gathering all session data from all windows...');
		
		// Get current session data
		const { sessions, currentSession } = await ipcRenderer.invoke('getSessions');
		const sessionData = sessions[currentSession];
		
		if (!sessionData) {
			Toast.error('Export Failed', 'No current session found');
			return;
		}
		
		// Get ALL session data including cookies from all windows/partitions
		const allSessionDataResult = await ipcRenderer.invoke('exportAllSessionData');
		
		if (!allSessionDataResult.success) {
			throw new Error(allSessionDataResult.error || 'Failed to export session data');
		}
		
		// Combine with current window's localStorage data
		const exportData = {
			sessionInfo: {
				name: sessionData.name,
				description: sessionData.description,
				createdAt: sessionData.createdAt,
				exportedAt: new Date().toISOString(),
				currentSessionId: currentSession
			},
			// Include all session data from all windows/partitions
			allSessions: allSessionDataResult.data,
			// Include current window's localStorage as well
			mainWindowLocalStorage: {
				socialStreamState: localStorage.getItem('socialStreamState'),
				settings: localStorage.getItem('settings'),
				betaMode: localStorage.getItem('betaMode'),
				youtubeAutoAdd: localStorage.getItem('youtubeAutoAdd'),
				youtubeAutoCleanup: localStorage.getItem('youtubeAutoCleanup'),
				youtubeCheckInterval: localStorage.getItem('youtubeCheckInterval'),
				cachedManifest: localStorage.getItem('cachedManifest'),
				config: localStorage.getItem('config'),
				language: localStorage.getItem('language')
			},
			version: '2.0'
		};
		
		// Create a blob and download it
		const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
		const url = URL.createObjectURL(blob);
		const a = document.createElement('a');
		a.href = url;
		a.download = `session-${sessionData.name.replace(/[^a-z0-9]/gi, '-')}-${new Date().toISOString().split('T')[0]}-complete.json`;
		document.body.appendChild(a);
		a.click();
		document.body.removeChild(a);
		URL.revokeObjectURL(url);
		
		// Show summary
		const sessionCount = Object.keys(allSessionDataResult.data.sessions).length;
		Toast.success('Export Complete', `Exported "${sessionData.name}" with data from ${sessionCount} windows/partitions`);
	} catch (e) {
		console.error('Error exporting session:', e);
		Toast.error('Export Failed', 'Failed to export session: ' + e.message);
	}
}

async function importSession() {
	try {
		// Create file input
		const input = document.createElement('input');
		input.type = 'file';
		input.accept = '.json';
		
		input.onchange = async (event) => {
			const file = event.target.files[0];
			if (!file) return;
			
			try {
				const content = await file.text();
				const importData = JSON.parse(content);
				
				// Validate the import data - support both old and new formats
				if (!importData.version || !importData.sessionInfo) {
					throw new Error('Invalid session file format');
				}
				
				// Check if this is the new format with all session data
				const isNewFormat = importData.version === '2.0' && importData.allSessions;
				
				// Prompt for session name
				const name = prompt('Enter a name for the imported session:', importData.sessionInfo.name || 'Imported Session');
				if (!name) return;
				
				const description = prompt('Enter a description (optional):', 
					importData.sessionInfo.description || `Imported from ${importData.sessionInfo.name} on ${new Date().toLocaleDateString()}`);
				
				// Create new session
				const result = await ipcRenderer.invoke('createSession', { name, description });
				if (!result.success) {
					throw new Error(result.error || 'Failed to create session');
				}
				
				// Ask if they want to switch to the imported session
				const switchNow = confirm('Session imported! Do you want to switch to it now?\n\nNote: This will restart the application and load the imported data.');
				
				if (switchNow) {
					if (isNewFormat) {
						// New format: Import all session data including cookies
						Toast.info('Importing...', 'Restoring all session data including cookies...');
						
						// Import all the session data (cookies, etc)
						const importResult = await ipcRenderer.invoke('importAllSessionData', importData.allSessions);
						
						if (!importResult.success) {
							throw new Error(importResult.error || 'Failed to import session data');
						}
						
						// Store the main window localStorage data
						localStorage.setItem('pendingImport', JSON.stringify(importData.mainWindowLocalStorage));
						
						// Store the full session data for window restoration
						await ipcRenderer.invoke('store-set', 'pendingSessionImport', importData.allSessions);
						
						const summary = `Imported ${importResult.results.totalSessions} sessions with ${importResult.results.totalCookies} cookies`;
						Toast.success('Import Progress', summary);
					} else {
						// Old format: Only localStorage
						localStorage.setItem('pendingImport', JSON.stringify(importData.localStorage));
					}
					
					// Switch to the new session
					await ipcRenderer.invoke('switchSession', result.sessionId);
				} else {
					if (isNewFormat) {
						// Import session data without switching
						Toast.info('Importing...', 'Restoring session data...');
						const importResult = await ipcRenderer.invoke('importAllSessionData', importData.allSessions);
						
						if (importResult.success) {
							const summary = `Imported ${importResult.results.totalSessions} sessions with ${importResult.results.totalCookies} cookies`;
							Toast.success('Import Complete', `Session "${name}" imported. ${summary}`);
						} else {
							Toast.warning('Partial Import', `Session "${name}" created but some data could not be imported`);
						}
					} else {
						Toast.success('Import Complete', `Session "${name}" imported successfully. You can switch to it later.`);
					}
					await loadSessions();
				}
				
			} catch (e) {
				console.error('Error processing import file:', e);
				Toast.error('Import Failed', 'Failed to import session: ' + e.message);
			}
		};
		
		input.click();
	} catch (e) {
		console.error('Error importing session:', e);
		Toast.error('Import Failed', 'Failed to import session');
	}
}

// Navigation handling
function showPage(pageName) {
	// Hide all pages
	const pages = document.querySelectorAll('#content-pane > div');
	pages.forEach(page => {
		page.style.display = 'none';
	});
	
	// Show the selected page
	const selectedPage = document.getElementById(pageName + '-page');
	if (selectedPage) {
		selectedPage.style.display = 'block';
		
		// Check if this page needs an iframe and create/update it
		const langCode = currentLanguage === 'pt-BR' ? 'pt' : currentLanguage;
		const existingIframe = selectedPage.querySelector('iframe');
		
		// Pages that should have iframes with socialstream.ninja content
		const iframePages = {
			'link-overlay': `https://socialstream.ninja/overlays/?ln=${langCode}`,
			'dashboard': `https://socialstream.ninja/dashboard/?ln=${langCode}`,
			'event-flow-editor': `https://socialstream.ninja/eventflow/?ln=${langCode}`,
			'vdo-ninja': `https://vdo.ninja/?ln=${langCode}`
		};
		
		if (iframePages[pageName]) {
			if (!existingIframe) {
				// Create iframe if it doesn't exist
				const iframe = document.createElement('iframe');
				iframe.style.width = '100%';
				iframe.style.height = '100%';
				iframe.style.border = 'none';
				iframe.src = iframePages[pageName];
				selectedPage.appendChild(iframe);
			} else {
				// Update existing iframe with language parameter
				try {
					if (existingIframe.src && existingIframe.src !== 'about:blank') {
						const url = new URL(existingIframe.src);
						url.searchParams.set('ln', langCode);
						if (existingIframe.src !== url.toString()) {
							existingIframe.src = url.toString();
						}
					}
				} catch (e) {
					console.error('Error updating iframe URL:', e);
					// If URL is invalid, just set the new URL
					existingIframe.src = iframePages[pageName];
				}
			}
		}
	}
	
	// Update active nav link
	const navLinks = document.querySelectorAll('#main-navigation a');
	navLinks.forEach(link => {
		link.classList.remove('active');
		if (link.getAttribute('data-page') === pageName) {
			link.classList.add('active');
		}
	});
	
	// Save current page to localStorage
	localStorage.setItem('currentPage', pageName);
	
	// Load sessions when sessions page is shown
	if (pageName === 'sessions') {
		loadSessions();
	}
}

// Translation system
const translations = {
	'en': {
		// Navigation
		'nav.streams': '🎭 Sources',
		'nav.linkoverlay': '🔗 Links and Settings',
		'nav.dashboard': '📰 Status and Logs',
		'nav.eventfloweditor': '🪤 Event Flow Editor',
		'nav.vdoninja': '🎦 Remote Camera Feed',
		'nav.sessions': '🧑‍🤝‍🧑 Sessions',
		
		// Buttons
		'btn.activate': '▶️ Activate source',
		'btn.signin': '🔑 Sign-in',
		'btn.help': '❓ Help!',
		'btn.stop': '⏹️ Stop',
		'btn.reload': '🔄 Reload',
		'btn.visible': '👁️ Visible',
		'btn.hidden': '🙈 Hidden',
		'btn.muted': '🔇 Muted',
		'btn.unmuted': '🔊 Volume',
		
		// Settings menu
		'settings.title': 'Additional settings for this source',
		'settings.header': 'Additional Controls',
		'settings.clear': '🧹 Clear cache & storage',
		'settings.remove': '🗑️ Remove source',
		
		// Sessions
		'sessions.title': 'User Sessions',
		'sessions.info': 'Manage multiple user profiles with separate settings and sources.',
		'sessions.current': 'Current Session',
		'sessions.available': 'Available Sessions',
		'sessions.create': '➕ Create New Session',
		'sessions.export': '💾 Export Current Session',
		'sessions.import': '📂 Import Session',
		'sessions.switch': 'Switch',
		'sessions.active': 'Active',
		
		// Sources
		'source.add': 'Add a new source:',
		'source.mode.standard': '📄 Standard',
		'source.mode.websocket': '🌐 WebSocket',
		'source.autoactivate': 'Auto-activate',
		'source.youtube.username': 'YouTube Username',
		'source.youtube.videoid': 'YouTube Video ID',
		'source.twitch': 'Twitch Username',
		'source.kick': 'Kick Username',
		'source.instagram': 'Instagram Username',
		'source.facebook': 'Facebook Username',
		'source.tiktok': 'TikTok Username',
		'source.other': 'Other chat sites',
		
		// App info
		'app.title': 'Social Stream Ninja Standalone',
		'app.newversion': 'NEW VERSION AVAILABLE',
		'app.download': 'Download new version here',
		
		// Groups
		'group.togglevisibility': 'Toggle All Streams Visibility',
		'group.togglemute': 'Toggle All Streams Mute',
		'group.stopall': 'Stop All Streams',
		'group.reloadall': 'Reload All Streams',
		'group.remove': '🗑️ Remove group & its sources',
	},
	
	'pt-BR': {
		// Navigation
		'nav.streams': '🎭 Fontes',
		'nav.linkoverlay': '🔗 Links e Configurações',
		'nav.dashboard': '📰 Status e Logs',
		'nav.eventfloweditor': '🪤 Editor de Fluxo de Eventos',
		'nav.vdoninja': '🎦 Feed de Câmera Remota',
		'nav.sessions': '🧑‍🤝‍🧑 Sessões',
		
		// Buttons
		'btn.activate': '▶️ Ativar fonte',
		'btn.signin': '🔑 Entrar',
		'btn.help': '❓ Ajuda!',
		'btn.stop': '⏹️ Parar',
		'btn.reload': '🔄 Recarregar',
		'btn.visible': '👁️ Visível',
		'btn.hidden': '🙈 Oculto',
		'btn.muted': '🔇 Mudo',
		'btn.unmuted': '🔊 Som',
		
		// Settings menu
		'settings.title': 'Configurações adicionais para esta fonte',
		'settings.header': 'Controles Adicionais',
		'settings.clear': '🧹 Limpar cache e armazenamento',
		'settings.remove': '🗑️ Remover fonte',
		
		// Sessions
		'sessions.title': 'Sessões de Usuário',
		'sessions.info': 'Gerencie múltiplos perfis de usuário com configurações e fontes separadas.',
		'sessions.current': 'Sessão Atual',
		'sessions.available': 'Sessões Disponíveis',
		'sessions.create': '➕ Criar Nova Sessão',
		'sessions.switch': 'Alternar',
		'sessions.active': 'Ativa',
		
		// Sources
		'source.add': 'Adicionar nova fonte:',
		'source.mode.standard': '📄 Padrão',
		'source.mode.websocket': '🌐 WebSocket',
		'source.autoactivate': 'Ativar automaticamente',
		'source.youtube.username': 'Nome de usuário do YouTube',
		'source.youtube.videoid': 'ID do vídeo do YouTube',
		'source.twitch': 'Nome de usuário do Twitch',
		'source.kick': 'Nome de usuário do Kick',
		'source.instagram': 'Nome de usuário do Instagram',
		'source.facebook': 'Nome de usuário do Facebook',
		'source.tiktok': 'Nome de usuário do TikTok',
		'source.other': 'Outros sites de chat',
		
		// App info
		'app.title': 'Social Stream Ninja Autônomo',
		'app.newversion': 'NOVA VERSÃO DISPONÍVEL',
		'app.download': 'Baixe a nova versão aqui',
		
		// Groups
		'group.togglevisibility': 'Alternar Visibilidade de Todas as Transmissões',
		'group.togglemute': 'Alternar Som de Todas as Transmissões',
		'group.stopall': 'Parar Todas as Transmissões',
		'group.reloadall': 'Recarregar Todas as Transmissões',
		'group.remove': '🗑️ Remover grupo e suas fontes',
	},
	
	'es': {
		// Navigation
		'nav.streams': '🎭 Fuentes',
		'nav.linkoverlay': '🔗 Enlaces y Configuración',
		'nav.dashboard': '📰 Estado y Registros',
		'nav.eventfloweditor': '🪤 Editor de Flujo de Eventos',
		'nav.vdoninja': '🎦 Transmisión de Cámara Remota',
		'nav.sessions': '🧑‍🤝‍🧑 Sesiones',
		
		// Buttons
		'btn.activate': '▶️ Activar fuente',
		'btn.signin': '🔑 Iniciar sesión',
		'btn.help': '❓ ¡Ayuda!',
		'btn.stop': '⏹️ Detener',
		'btn.reload': '🔄 Recargar',
		'btn.visible': '👁️ Visible',
		'btn.hidden': '🙈 Oculto',
		'btn.muted': '🔇 Silenciado',
		'btn.unmuted': '🔊 Sonido',
		
		// Settings menu
		'settings.title': 'Configuración adicional para esta fuente',
		'settings.header': 'Controles Adicionales',
		'settings.clear': '🧹 Limpiar caché y almacenamiento',
		'settings.remove': '🗑️ Eliminar fuente',
		
		// Sessions
		'sessions.title': 'Sesiones de Usuario',
		'sessions.info': 'Gestione múltiples perfiles de usuario con configuraciones y fuentes separadas.',
		'sessions.current': 'Sesión Actual',
		'sessions.available': 'Sesiones Disponibles',
		'sessions.create': '➕ Crear Nueva Sesión',
		'sessions.switch': 'Cambiar',
		'sessions.active': 'Activa',
		
		// Sources
		'source.add': 'Añadir nueva fuente',
		'source.mode.standard': '📄 Estándar',
		'source.mode.websocket': '🌐 WebSocket',
		'source.autoactivate': 'Activar automáticamente',
		'source.youtube.username': 'Nombre de usuario de YouTube',
		'source.youtube.videoid': 'ID de video de YouTube',
		'source.twitch': 'Nombre de usuario de Twitch',
		'source.kick': 'Nombre de usuario de Kick',
		'source.instagram': 'Nombre de usuario de Instagram',
		'source.facebook': 'Nombre de usuario de Facebook',
		'source.tiktok': 'Nombre de usuario de TikTok',
		'source.other': 'Otros sitios de chat',
		
		// App info
		'app.title': 'Social Stream Ninja Independiente',
		'app.newversion': 'NUEVA VERSIÓN DISPONIBLE',
		'app.download': 'Descarga la nueva versión aquí',
		
		// Groups
		'group.togglevisibility': 'Alternar Visibilidad de Todas las Transmisiones',
		'group.togglemute': 'Alternar Sonido de Todas las Transmisiones',
		'group.stopall': 'Detener Todas las Transmisiones',
		'group.reloadall': 'Recargar Todas las Transmisiones',
		'group.remove': '🗑️ Eliminar grupo y sus fuentes',
	},
	
	'fr': {
		// Navigation
		'nav.streams': '🎭 Sources',
		'nav.linkoverlay': '🔗 Liens et Paramètres',
		'nav.dashboard': '📰 État et Journaux',
		'nav.eventfloweditor': '🪤 Éditeur de Flux d\'Événements',
		'nav.vdoninja': '🎦 Flux de Caméra à Distance',
		'nav.sessions': '🧑‍🤝‍🧑 Sessions',
		
		// Buttons
		'btn.activate': '▶️ Activer la source',
		'btn.signin': '🔑 Se connecter',
		'btn.help': '❓ Aide!',
		'btn.stop': '⏹️ Arrêter',
		'btn.reload': '🔄 Recharger',
		'btn.visible': '👁️ Visible',
		'btn.hidden': '🙈 Caché',
		'btn.muted': '🔇 Muet',
		'btn.unmuted': '🔊 Son',
		
		// Settings menu
		'settings.title': 'Paramètres supplémentaires pour cette source',
		'settings.header': 'Contrôles Supplémentaires',
		'settings.clear': '🧹 Effacer le cache et le stockage',
		'settings.remove': '🗑️ Supprimer la source',
		
		// Sessions
		'sessions.title': 'Sessions Utilisateur',
		'sessions.info': 'Gérez plusieurs profils utilisateur avec des paramètres et sources séparés.',
		'sessions.current': 'Session Actuelle',
		'sessions.available': 'Sessions Disponibles',
		'sessions.create': '➕ Créer une Nouvelle Session',
		'sessions.switch': 'Changer',
		'sessions.active': 'Active',
		
		// Sources
		'source.add': 'Ajouter une nouvelle source',
		'source.mode.standard': '📄 Standard',
		'source.mode.websocket': '🌐 WebSocket',
		'source.autoactivate': 'Activation automatique',
		'source.youtube.username': 'Nom d\'utilisateur YouTube',
		'source.youtube.videoid': 'ID de vidéo YouTube',
		'source.twitch': 'Nom d\'utilisateur Twitch',
		'source.kick': 'Nom d\'utilisateur Kick',
		'source.instagram': 'Nom d\'utilisateur Instagram',
		'source.facebook': 'Nom d\'utilisateur Facebook',
		'source.tiktok': 'Nom d\'utilisateur TikTok',
		'source.other': 'Autres sites de chat',
		
		// App info
		'app.title': 'Social Stream Ninja Autonome',
		'app.newversion': 'NOUVELLE VERSION DISPONIBLE',
		'app.download': 'Téléchargez la nouvelle version ici',
		
		// Groups
		'group.togglevisibility': 'Basculer la Visibilité de Tous les Flux',
		'group.togglemute': 'Basculer le Son de Tous les Flux',
		'group.stopall': 'Arrêter Tous les Flux',
		'group.reloadall': 'Recharger Tous les Flux',
		'group.remove': '🗑️ Supprimer le groupe et ses sources',
	},
	
	'de': {
		// Navigation
		'nav.streams': '🎭 Quellen',
		'nav.linkoverlay': '🔗 Links und Einstellungen',
		'nav.dashboard': '📰 Status und Protokolle',
		'nav.eventfloweditor': '🪤 Ereignisfluss-Editor',
		'nav.vdoninja': '🎦 Remote-Kamera-Feed',
		'nav.sessions': '🧑‍🤝‍🧑 Sitzungen',
		
		// Buttons
		'btn.activate': '▶️ Quelle aktivieren',
		'btn.signin': '🔑 Anmelden',
		'btn.help': '❓ Hilfe!',
		'btn.stop': '⏹️ Stoppen',
		'btn.reload': '🔄 Neu laden',
		'btn.visible': '👁️ Sichtbar',
		'btn.hidden': '🙈 Versteckt',
		'btn.muted': '🔇 Stumm',
		'btn.unmuted': '🔊 Ton',
		
		// Settings menu
		'settings.title': 'Zusätzliche Einstellungen für diese Quelle',
		'settings.header': 'Zusätzliche Steuerungen',
		'settings.clear': '🧹 Cache und Speicher löschen',
		'settings.remove': '🗑️ Quelle entfernen',
		
		// Sessions
		'sessions.title': 'Benutzersitzungen',
		'sessions.info': 'Verwalten Sie mehrere Benutzerprofile mit separaten Einstellungen und Quellen.',
		'sessions.current': 'Aktuelle Sitzung',
		'sessions.available': 'Verfügbare Sitzungen',
		'sessions.create': '➕ Neue Sitzung erstellen',
		'sessions.switch': 'Wechseln',
		'sessions.active': 'Aktiv',
		
		// Sources
		'source.add': 'Neue Quelle hinzufügen',
		'source.mode.standard': '📄 Standard',
		'source.mode.websocket': '🌐 WebSocket',
		'source.autoactivate': 'Automatisch aktivieren',
		'source.youtube.username': 'YouTube-Benutzername',
		'source.youtube.videoid': 'YouTube-Video-ID',
		'source.twitch': 'Twitch-Benutzername',
		'source.kick': 'Kick-Benutzername',
		'source.instagram': 'Instagram-Benutzername',
		'source.facebook': 'Facebook-Benutzername',
		'source.tiktok': 'TikTok-Benutzername',
		'source.other': 'Andere Chat-Seiten',
		
		// App info
		'app.title': 'Social Stream Ninja Eigenständig',
		'app.newversion': 'NEUE VERSION VERFÜGBAR',
		'app.download': 'Neue Version hier herunterladen',
		
		// Groups
		'group.togglevisibility': 'Sichtbarkeit aller Streams umschalten',
		'group.togglemute': 'Ton aller Streams umschalten',
		'group.stopall': 'Alle Streams stoppen',
		'group.reloadall': 'Alle Streams neu laden',
		'group.remove': '🗑️ Gruppe und ihre Quellen entfernen',
	},
	
	'it': {
		// Navigation
		'nav.streams': '🎭 Fonti',
		'nav.linkoverlay': '🔗 Collegamenti e Impostazioni',
		'nav.dashboard': '📰 Stato e Registri',
		'nav.eventfloweditor': '🪤 Editor di Flusso Eventi',
		'nav.vdoninja': '🎦 Feed Telecamera Remota',
		'nav.sessions': '🧑‍🤝‍🧑 Sessioni',
		
		// Buttons
		'btn.activate': '▶️ Attiva fonte',
		'btn.signin': '🔑 Accedi',
		'btn.help': '❓ Aiuto!',
		'btn.stop': '⏹️ Ferma',
		'btn.reload': '🔄 Ricarica',
		'btn.visible': '👁️ Visibile',
		'btn.hidden': '🙈 Nascosto',
		'btn.muted': '🔇 Muto',
		'btn.unmuted': '🔊 Audio',
		
		// Settings menu
		'settings.title': 'Impostazioni aggiuntive per questa fonte',
		'settings.header': 'Controlli Aggiuntivi',
		'settings.clear': '🧹 Cancella cache e archiviazione',
		'settings.remove': '🗑️ Rimuovi fonte',
		
		// Sessions
		'sessions.title': 'Sessioni Utente',
		'sessions.info': 'Gestisci più profili utente con impostazioni e fonti separate.',
		'sessions.current': 'Sessione Corrente',
		'sessions.available': 'Sessioni Disponibili',
		'sessions.create': '➕ Crea Nuova Sessione',
		'sessions.switch': 'Cambia',
		'sessions.active': 'Attiva',
		
		// Sources
		'source.add': 'Aggiungi nuova fonte',
		'source.mode.standard': '📄 Standard',
		'source.mode.websocket': '🌐 WebSocket',
		'source.autoactivate': 'Attivazione automatica',
		'source.youtube.username': 'Nome utente YouTube',
		'source.youtube.videoid': 'ID video YouTube',
		'source.twitch': 'Nome utente Twitch',
		'source.kick': 'Nome utente Kick',
		'source.instagram': 'Nome utente Instagram',
		'source.facebook': 'Nome utente Facebook',
		'source.tiktok': 'Nome utente TikTok',
		'source.other': 'Altri siti di chat',
		
		// App info
		'app.title': 'Social Stream Ninja Autonomo',
		'app.newversion': 'NUOVA VERSIONE DISPONIBILE',
		'app.download': 'Scarica la nuova versione qui',
		
		// Groups
		'group.togglevisibility': 'Attiva/Disattiva Visibilità di Tutti i Flussi',
		'group.togglemute': 'Attiva/Disattiva Audio di Tutti i Flussi',
		'group.stopall': 'Ferma Tutti i Flussi',
		'group.reloadall': 'Ricarica Tutti i Flussi',
		'group.remove': '🗑️ Rimuovi gruppo e le sue fonti',
	},
	
	'ja': {
		// Navigation
		'nav.streams': '🎭 ソース',
		'nav.linkoverlay': '🔗 リンクと設定',
		'nav.dashboard': '📰 ステータスとログ',
		'nav.eventfloweditor': '🪤 イベントフローエディター',
		'nav.vdoninja': '🎦 リモートカメラフィード',
		'nav.sessions': '🧑‍🤝‍🧑 セッション',
		
		// Buttons
		'btn.activate': '▶️ ソースを有効化',
		'btn.signin': '🔑 サインイン',
		'btn.help': '❓ ヘルプ！',
		'btn.stop': '⏹️ 停止',
		'btn.reload': '🔄 リロード',
		'btn.visible': '👁️ 表示',
		'btn.hidden': '🙈 非表示',
		'btn.muted': '🔇 ミュート',
		'btn.unmuted': '🔊 音声',
		
		// Settings menu
		'settings.title': 'このソースの追加設定',
		'settings.header': '追加コントロール',
		'settings.clear': '🧹 キャッシュとストレージをクリア',
		'settings.remove': '🗑️ ソースを削除',
		
		// Sessions
		'sessions.title': 'ユーザーセッション',
		'sessions.info': '別々の設定とソースで複数のユーザープロファイルを管理します。',
		'sessions.current': '現在のセッション',
		'sessions.available': '利用可能なセッション',
		'sessions.create': '➕ 新しいセッションを作成',
		'sessions.switch': '切り替え',
		'sessions.active': 'アクティブ',
		
		// Sources
		'source.add': '新しいソースを追加',
		'source.mode.standard': '📄 スタンダード',
		'source.mode.websocket': '🌐 WebSocket',
		'source.autoactivate': '自動有効化',
		'source.youtube.username': 'YouTubeユーザー名',
		'source.youtube.videoid': 'YouTube動画ID',
		'source.twitch': 'Twitchユーザー名',
		'source.kick': 'Kickユーザー名',
		'source.instagram': 'Instagramユーザー名',
		'source.facebook': 'Facebookユーザー名',
		'source.tiktok': 'TikTokユーザー名',
		'source.other': 'その他のチャットサイト',
		
		// App info
		'app.title': 'Social Stream Ninja スタンドアロン',
		'app.newversion': '新しいバージョンが利用可能',
		'app.download': 'こちらから新バージョンをダウンロード',
		
		// Groups
		'group.togglevisibility': 'すべてのストリームの表示を切り替え',
		'group.togglemute': 'すべてのストリームのミュートを切り替え',
		'group.stopall': 'すべてのストリームを停止',
		'group.reloadall': 'すべてのストリームをリロード',
		'group.remove': '🗑️ グループとそのソースを削除',
	},
	
	'zh': {
		// Navigation
		'nav.streams': '🎭 来源',
		'nav.linkoverlay': '🔗 链接和设置',
		'nav.dashboard': '📰 状态和日志',
		'nav.eventfloweditor': '🪤 事件流编辑器',
		'nav.vdoninja': '🎦 远程摄像头画面',
		'nav.sessions': '🧑‍🤝‍🧑 会话',
		
		// Buttons
		'btn.activate': '▶️ 激活来源',
		'btn.signin': '🔑 登录',
		'btn.help': '❓ 帮助！',
		'btn.stop': '⏹️ 停止',
		'btn.reload': '🔄 重新加载',
		'btn.visible': '👁️ 可见',
		'btn.hidden': '🙈 隐藏',
		'btn.muted': '🔇 静音',
		'btn.unmuted': '🔊 音量',
		
		// Settings menu
		'settings.title': '此来源的附加设置',
		'settings.header': '附加控制',
		'settings.clear': '🧹 清除缓存和存储',
		'settings.remove': '🗑️ 删除来源',
		
		// Sessions
		'sessions.title': '用户会话',
		'sessions.info': '使用单独的设置和来源管理多个用户配置文件。',
		'sessions.current': '当前会话',
		'sessions.available': '可用会话',
		'sessions.create': '➕ 创建新会话',
		'sessions.switch': '切换',
		'sessions.active': '活动',
		
		// Sources
		'source.add': '添加新来源',
		'source.mode.standard': '📄 标准',
		'source.mode.websocket': '🌐 WebSocket',
		'source.autoactivate': '自动激活',
		'source.youtube.username': 'YouTube用户名',
		'source.youtube.videoid': 'YouTube视频ID',
		'source.twitch': 'Twitch用户名',
		'source.kick': 'Kick用户名',
		'source.instagram': 'Instagram用户名',
		'source.facebook': 'Facebook用户名',
		'source.tiktok': 'TikTok用户名',
		'source.other': '其他聊天网站',
		
		// App info
		'app.title': 'Social Stream Ninja 独立版',
		'app.newversion': '新版本可用',
		'app.download': '在此下载新版本',
		
		// Groups
		'group.togglevisibility': '切换所有流的可见性',
		'group.togglemute': '切换所有流的静音',
		'group.stopall': '停止所有流',
		'group.reloadall': '重新加载所有流',
		'group.remove': '🗑️ 删除组及其来源',
	},
	
	'ko': {
		// Navigation
		'nav.streams': '🎭 소스',
		'nav.linkoverlay': '🔗 링크 및 설정',
		'nav.dashboard': '📰 상태 및 로그',
		'nav.eventfloweditor': '🪤 이벤트 플로우 편집기',
		'nav.vdoninja': '🎦 원격 카메라 피드',
		'nav.sessions': '🧑‍🤝‍🧑 세션',
		
		// Buttons
		'btn.activate': '▶️ 소스 활성화',
		'btn.signin': '🔑 로그인',
		'btn.help': '❓ 도움말!',
		'btn.stop': '⏹️ 중지',
		'btn.reload': '🔄 새로고침',
		'btn.visible': '👁️ 보이기',
		'btn.hidden': '🙈 숨기기',
		'btn.muted': '🔇 음소거',
		'btn.unmuted': '🔊 소리',
		
		// Settings menu
		'settings.title': '이 소스의 추가 설정',
		'settings.header': '추가 컨트롤',
		'settings.clear': '🧹 캐시 및 저장소 지우기',
		'settings.remove': '🗑️ 소스 제거',
		
		// Sessions
		'sessions.title': '사용자 세션',
		'sessions.info': '별도의 설정과 소스로 여러 사용자 프로필을 관리합니다.',
		'sessions.current': '현재 세션',
		'sessions.available': '사용 가능한 세션',
		'sessions.create': '➕ 새 세션 만들기',
		'sessions.switch': '전환',
		'sessions.active': '활성',
		
		// Sources
		'source.add': '새 소스 추가',
		'source.mode.standard': '📄 표준',
		'source.mode.websocket': '🌐 WebSocket',
		'source.autoactivate': '자동 활성화',
		'source.youtube.username': 'YouTube 사용자명',
		'source.youtube.videoid': 'YouTube 동영상 ID',
		'source.twitch': 'Twitch 사용자명',
		'source.kick': 'Kick 사용자명',
		'source.instagram': 'Instagram 사용자명',
		'source.facebook': 'Facebook 사용자명',
		'source.tiktok': 'TikTok 사용자명',
		'source.other': '기타 채팅 사이트',
		
		// App info
		'app.title': 'Social Stream Ninja 독립형',
		'app.newversion': '새 버전 사용 가능',
		'app.download': '여기서 새 버전 다운로드',
		
		// Groups
		'group.togglevisibility': '모든 스트림 표시 전환',
		'group.togglemute': '모든 스트림 음소거 전환',
		'group.stopall': '모든 스트림 중지',
		'group.reloadall': '모든 스트림 새로고침',
		'group.remove': '🗑️ 그룹 및 소스 제거',
	},
	
	'ru': {
		// Navigation
		'nav.streams': '🎭 Источники',
		'nav.linkoverlay': '🔗 Ссылки и настройки',
		'nav.dashboard': '📰 Статус и журналы',
		'nav.eventfloweditor': '🪤 Редактор потока событий',
		'nav.vdoninja': '🎦 Удаленная трансляция камеры',
		'nav.sessions': '🧑‍🤝‍🧑 Сессии',
		
		// Buttons
		'btn.activate': '▶️ Активировать источник',
		'btn.signin': '🔑 Войти',
		'btn.help': '❓ Помощь!',
		'btn.stop': '⏹️ Остановить',
		'btn.reload': '🔄 Перезагрузить',
		'btn.visible': '👁️ Видимый',
		'btn.hidden': '🙈 Скрытый',
		'btn.muted': '🔇 Без звука',
		'btn.unmuted': '🔊 Звук',
		
		// Settings menu
		'settings.title': 'Дополнительные настройки для этого источника',
		'settings.header': 'Дополнительные элементы управления',
		'settings.clear': '🧹 Очистить кэш и хранилище',
		'settings.remove': '🗑️ Удалить источник',
		
		// Sessions
		'sessions.title': 'Пользовательские сессии',
		'sessions.info': 'Управляйте несколькими профилями пользователей с отдельными настройками и источниками.',
		'sessions.current': 'Текущая сессия',
		'sessions.available': 'Доступные сессии',
		'sessions.create': '➕ Создать новую сессию',
		'sessions.switch': 'Переключить',
		'sessions.active': 'Активная',
		
		// Sources
		'source.add': 'Добавить новый источник',
		'source.mode.standard': '📄 Стандартный',
		'source.mode.websocket': '🌐 WebSocket',
		'source.autoactivate': 'Автоактивация',
		'source.youtube.username': 'Имя пользователя YouTube',
		'source.youtube.videoid': 'ID видео YouTube',
		'source.twitch': 'Имя пользователя Twitch',
		'source.kick': 'Имя пользователя Kick',
		'source.instagram': 'Имя пользователя Instagram',
		'source.facebook': 'Имя пользователя Facebook',
		'source.tiktok': 'Имя пользователя TikTok',
		'source.other': 'Другие чат-сайты',
		
		// App info
		'app.title': 'Social Stream Ninja Автономный',
		'app.newversion': 'ДОСТУПНА НОВАЯ ВЕРСИЯ',
		'app.download': 'Скачайте новую версию здесь',
		
		// Groups
		'group.togglevisibility': 'Переключить видимость всех потоков',
		'group.togglemute': 'Переключить звук всех потоков',
		'group.stopall': 'Остановить все потоки',
		'group.reloadall': 'Перезагрузить все потоки',
		'group.remove': '🗑️ Удалить группу и её источники',
	},
	
	'tr': {
		// Navigation
		'nav.streams': '🎭 Kaynaklar',
		'nav.linkoverlay': '🔗 Bağlantılar ve Ayarlar',
		'nav.dashboard': '📰 Durum ve Günlükler',
		'nav.eventfloweditor': '🪤 Olay Akış Düzenleyici',
		'nav.vdoninja': '🎦 Uzak Kamera Yayını',
		'nav.sessions': '🧑‍🤝‍🧑 Oturumlar',
		
		// Buttons
		'btn.activate': '▶️ Kaynağı etkinleştir',
		'btn.signin': '🔑 Giriş yap',
		'btn.help': '❓ Yardım!',
		'btn.stop': '⏹️ Durdur',
		'btn.reload': '🔄 Yenile',
		'btn.visible': '👁️ Görünür',
		'btn.hidden': '🙈 Gizli',
		'btn.muted': '🔇 Sessiz',
		'btn.unmuted': '🔊 Ses',
		
		// Settings menu
		'settings.title': 'Bu kaynak için ek ayarlar',
		'settings.header': 'Ek Kontroller',
		'settings.clear': '🧹 Önbelleği ve depolamayı temizle',
		'settings.remove': '🗑️ Kaynağı kaldır',
		
		// Sessions
		'sessions.title': 'Kullanıcı Oturumları',
		'sessions.info': 'Ayrı ayarlar ve kaynaklarla birden fazla kullanıcı profilini yönetin.',
		'sessions.current': 'Mevcut Oturum',
		'sessions.available': 'Kullanılabilir Oturumlar',
		'sessions.create': '➕ Yeni Oturum Oluştur',
		'sessions.export': '💾 Mevcut Oturumu Dışa Aktar',
		'sessions.import': '📂 Oturum İçe Aktar',
		'sessions.switch': 'Değiştir',
		'sessions.active': 'Aktif',
		
		// Sources
		'source.add': 'Yeni kaynak ekle:',
		'source.mode.standard': '📄 Standart',
		'source.mode.websocket': '🌐 WebSocket',
		'source.autoactivate': 'Otomatik etkinleştir',
		'source.youtube.username': 'YouTube Kullanıcı Adı',
		'source.youtube.videoid': 'YouTube Video ID',
		'source.twitch': 'Twitch Kullanıcı Adı',
		'source.kick': 'Kick Kullanıcı Adı',
		'source.instagram': 'Instagram Kullanıcı Adı',
		'source.facebook': 'Facebook Kullanıcı Adı',
		'source.tiktok': 'TikTok Kullanıcı Adı',
		'source.other': 'Diğer sohbet siteleri',
		
		// App info
		'app.title': 'Social Stream Ninja Bağımsız',
		'app.newversion': 'YENİ SÜRÜM MEVCUT',
		'app.download': 'Yeni sürümü buradan indirin',
		
		// Groups
		'group.togglevisibility': 'Tüm Yayınların Görünürlüğünü Değiştir',
		'group.togglemute': 'Tüm Yayınların Sesini Değiştir',
		'group.stopall': 'Tüm Yayınları Durdur',
		'group.reloadall': 'Tüm Yayınları Yenile',
		'group.remove': '🗑️ Grubu ve kaynaklarını kaldır',
	}
};

let currentLanguage = localStorage.getItem('language') || 'en';

function translate(key) {
	return translations[currentLanguage]?.[key] || translations['en'][key] || key;
}

function changeLanguage(lang) {
	currentLanguage = lang;
	localStorage.setItem('language', lang);
	
	// Update navigation links
	document.querySelectorAll('#main-navigation a').forEach(link => {
		const page = link.getAttribute('data-page');
		if (page) {
			const translationKey = `nav.${page.replace(/-/g, '')}`;
			link.textContent = translate(translationKey);
		}
	});
	
	// Update all translatable elements
	document.querySelectorAll('[data-i18n]').forEach(element => {
		const key = element.getAttribute('data-i18n');
		if (element.tagName === 'INPUT' || element.tagName === 'BUTTON') {
			if (element.hasAttribute('placeholder')) {
				element.placeholder = translate(key);
			} else {
				element.textContent = translate(key);
			}
		} else {
			element.textContent = translate(key);
		}
	});
	
	// Update dynamically created content
	updateDynamicTranslations();
	
	// Refresh all iframes with new language parameter
	refreshIframesWithLanguage();
}

function refreshIframesWithLanguage() {
	// Get the language code (convert pt-BR to pt for URL parameter)
	const langCode = currentLanguage === 'pt-BR' ? 'pt' : currentLanguage;
	
	// Map our language codes to popup.html language codes
	const languageMap = {
		'en': '',  // Default
		'de': 'de',
		'es': 'es',
		'pt-BR': 'pt-br',
		'fr': 'fr',  // Add if supported
		'it': 'it',  // Add if supported
		'ja': 'ja',  // Add if supported
		'zh': 'zh',  // Add if supported
		'ko': 'ko',  // Add if supported
		'ru': 'ru',  // Add if supported
		'tr': 'tr',
		'uk': 'uk'
	};
	
	const popupLangCode = languageMap[currentLanguage] || '';
	
	// Find all iframes in the content pane
	document.querySelectorAll('#content-pane iframe').forEach(iframe => {
		if (iframe.src && iframe.src !== 'about:blank') {
			try {
				// Send a message to the iframe to change language
				iframe.contentWindow.postMessage({
					type: 'changeLanguage',
					language: popupLangCode
				}, '*');
			} catch (e) {
				console.error('Error sending language message to iframe:', e);
			}
		}
	});
	
	// Also update any webviews that might be in sources
	document.querySelectorAll('webview').forEach(webview => {
		if (webview.src && webview.src !== 'about:blank') {
			try {
				const url = new URL(webview.src);
				url.searchParams.set('ln', langCode);
				webview.src = url.toString();
			} catch (e) {
				console.error('Error updating webview language:', e, webview.src);
			}
		}
	});
}

function updateDynamicTranslations() {
	// Update button texts in sources
	document.querySelectorAll('[data-activatehtml]').forEach(btn => {
		if (!btn.classList.contains('hidden')) {
			btn.textContent = translate('btn.activate');
		}
	});
	
	document.querySelectorAll('[data-signin]').forEach(btn => {
		btn.textContent = translate('btn.signin');
	});
	
	document.querySelectorAll('[data-showtips]').forEach(btn => {
		btn.textContent = translate('btn.help');
	});
	
	// Update mode selector options
	document.querySelectorAll('.mode-option').forEach(option => {
		if (option.dataset.mode === 'classic') {
			option.textContent = translate('source.mode.standard');
		} else if (option.dataset.mode === 'websocket' || option.dataset.mode === 'tiktok-websocket') {
			option.textContent = translate('source.mode.websocket');
		}
	});
	
	// Update toggle labels
	document.querySelectorAll('.toggle-label').forEach(label => {
		if (label.textContent.includes('Auto-activate')) {
			label.textContent = translate('source.autoactivate');
		}
	});
	
	// Update source buttons
	const sourceTypeMap = {
		'youtube-username': 'source.youtube.username',
		'youtube-videoid': 'source.youtube.videoid',
		'twitch': 'source.twitch',
		'kick': 'source.kick',
		'instagram': 'source.instagram',
		'facebook': 'source.facebook',
		'tiktok': 'source.tiktok',
		'other': 'source.other'
	};
	
	document.querySelectorAll('.addnew button[data-source-type]').forEach(btn => {
		const sourceType = btn.getAttribute('data-source-type');
		if (sourceTypeMap[sourceType]) {
			const img = btn.querySelector('img');
			if (img) {
				btn.innerHTML = img.outerHTML + translate(sourceTypeMap[sourceType]);
			}
		}
	});
}

// Toggle mobile menu
function toggleMenu() {
	const navList = document.querySelector('#main-navigation ul');
	navList.classList.toggle('active');
}

// Close mobile menu when clicking outside
document.addEventListener('click', (e) => {
	const nav = document.getElementById('main-navigation');
	const menuToggle = document.querySelector('.menu-toggle');
	const navList = document.querySelector('#main-navigation ul');
	
	if (!nav.contains(e.target) && navList.classList.contains('active')) {
		navList.classList.remove('active');
	}
});

// Set up navigation
document.addEventListener('DOMContentLoaded', () => {
	// Initialize language
	const savedLanguage = localStorage.getItem('language') || 'en';
	document.getElementById('language-select').value = savedLanguage;
	changeLanguage(savedLanguage);
	
	const navLinks = document.querySelectorAll('#main-navigation a');
	navLinks.forEach(link => {
		link.addEventListener('click', (e) => {
			e.preventDefault();
			const page = e.target.getAttribute('data-page');
			if (page) {
				showPage(page);
				// Close mobile menu after navigation
				const navList = document.querySelector('#main-navigation ul');
				navList.classList.remove('active');
			}
		});
	});
	
	// Restore last active page or show streams by default
	const savedPage = localStorage.getItem('currentPage') || 'streams';
	
	// If the saved page is event-flow-editor, we need to ensure the iframe loads with the correct view
	if (savedPage === 'event-flow-editor') {
		// Add a marker so setupIframeSource knows to load the editor view
		window.initialEditorView = true;
	}
	
	// Small delay to ensure all elements are loaded
	setTimeout(() => {
		showPage(savedPage);
	}, 100);
});

async function toggleYouTubeType(button) {
    try {
        const sourceElement = button.closest('[data-source-id]');
        if (!sourceElement) {
            console.error('toggleYouTubeType: No source element found');
            return;
        }
        
        const sourceId = sourceElement.dataset.sourceId;
        const source = stateManager.getSource(sourceId);
        if (!source) {
            console.error('toggleYouTubeType: Source not found for ID:', sourceId);
            return;
        }
        
        // Only allow for YouTube sources
        if (source.target !== 'youtube' && source.target !== 'youtubeshorts') {
            console.error('toggleYouTubeType: Not a YouTube source:', source.target);
            return;
        }
        
        // Don't allow toggle if source is active
        if (source.status === 'active' || source.vid || source.wssId) {
            alert("Cannot change type while source is active. Please stop the source first.");
            return;
        }
        
        const currentType = source.target;
        const newType = currentType === 'youtube' ? 'youtubeshorts' : 'youtube';
    
    // Update the source in state manager
    let newUrl = source.url;
    if (currentType === 'youtube' && newType === 'youtubeshorts') {
        // Add &shorts if not already present
        if (!newUrl.includes('&shorts')) {
            newUrl += '&shorts';
        }
    } else if (currentType === 'youtubeshorts' && newType === 'youtube') {
        // Remove &shorts
        newUrl = newUrl.replace('&shorts', '');
    }
    
    const updates = {
        target: newType,
        url: newUrl
    };
    
    stateManager.updateSource(sourceId, updates);
    
    // Update the UI
    const updatedSource = stateManager.getSource(sourceId);
    updateSourceUI(sourceElement, updatedSource);
    
    // Update the group if needed
    if (source.groupId) {
        const oldGroupId = source.groupId; // Store old group ID before it changes
        const oldGroup = stateManager.getGroup(oldGroupId);
        if (oldGroup && oldGroup.target !== newType) {
            // Find or create the appropriate group
            let newGroup = stateManager.getGroups().find(g => 
                g.username === oldGroup.username && g.target === newType
            );
            
            if (!newGroup) {
                // Create new group
                const newGroupId = stateManager.addGroup({
                    target: newType,
                    username: oldGroup.username,
                    isChannel: oldGroup.isChannel,
                    autoActivate: oldGroup.autoActivate,
                    groupVisible: oldGroup.groupVisible,
                    groupMuted: oldGroup.groupMuted
                });
                newGroup = stateManager.getGroup(newGroupId);
            }
            
            // Move source to new group
            stateManager.moveSourceToGroup(sourceId, newGroup.id);
            
            // Refresh UI - move element to new group
            const newGroupElement = document.querySelector(`[data-group-id="${newGroup.id}"]`);
            if (newGroupElement) {
                const streamsContainer = newGroupElement.querySelector('.stream-group');
                if (streamsContainer) {
                    streamsContainer.appendChild(sourceElement);
                }
            } else if (!newGroupElement && newGroup) {
                // If the group element doesn't exist yet, create it
                const groupElement = createGroupElement(newGroup.id);
                if (groupElement) {
                    document.getElementById("sources").appendChild(groupElement);
                    const streamsContainer = groupElement.querySelector('.stream-group');
                    if (streamsContainer) {
                        streamsContainer.appendChild(sourceElement);
                    }
                }
            }
            
            // Clean up old group if empty
            const remainingSourcesInOldGroup = stateManager.getSources({ groupId: oldGroupId });
            if (remainingSourcesInOldGroup.length === 0) {
                const oldGroupElement = document.querySelector(`[data-group-id="${oldGroupId}"]`);
                if (oldGroupElement) {
                    oldGroupElement.remove();
                }
                stateManager.removeGroup(oldGroupId);
            }
        }
    }
    
    console.log(`Toggled YouTube type from ${currentType} to ${newType} for source ${sourceId}`);
    } catch (error) {
        console.error('Error in toggleYouTubeType:', error);
        alert('An error occurred while changing the YouTube type. Please try again.');
    }
}

// User Agent Management Functions
const defaultUserAgents = [
  {
    "name": "Chrome - Windows",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36"
  },
  {
    "name": "Chrome - Mac",
    "value": "Mozilla/5.0 (Macintosh; Intel Mac OS X 14_7_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36"
  },
  {
    "name": "Chrome - Linux",
    "value": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36"
  },
  {
    "name": "Firefox - Windows",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:137.0) Gecko/20100101 Firefox/137.0"
  },
  {
    "name": "Firefox - Mac",
    "value": "Mozilla/5.0 (Macintosh; Intel Mac OS X 14.7; rv:137.0) Gecko/20100101 Firefox/137.0"
  },
  {
    "name": "Safari - Mac",
    "value": "Mozilla/5.0 (Macintosh; Intel Mac OS X 14_7_5) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.3 Safari/605.1.15"
  },
  {
    "name": "Edge - Windows",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36 Edg/138.0.0.0"
  },
  {
    "name": "Opera - Windows",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36 OPR/124.0.0.0"
  },
  {
    "name": "Chrome - Android",
    "value": "Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Mobile Safari/537.36"
  },
  {
    "name": "Firefox - Android",
    "value": "Mozilla/5.0 (Android 15; Mobile; rv:136.0) Gecko/136.0 Firefox/136.0"
  },
  {
    "name": "Samsung Internet - Android",
    "value": "Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) SamsungBrowser/23.0 Chrome/134.0.0.0 Mobile Safari/537.36"
  },
  {
    "name": "Safari - iPhone",
    "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_7_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.3 Mobile/15E148 Safari/605.1.15"
  },
  {
    "name": "Chrome - iPhone",
    "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) CriOS/134.0.0.0 Mobile/15E148 Safari/604.1"
  },
  {
    "name": "Edge - iPhone",
    "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_7_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) EdgiOS/134.0.0.0 Mobile/15E148 Safari/604.1"
  },
  {
    "name": "Generic Chrome - Windows (No Version)",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome Safari/537.36"
  },
  {
    "name": "Generic Firefox - Windows (No Version)",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv) Gecko/20100101 Firefox"
  },
  {
    "name": "Generic Safari - Mac (No Version)",
    "value": "Mozilla/5.0 (Macintosh; Intel Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version Safari/605.1.15"
  },
  {
    "name": "Generic Edge - Windows (No Version)",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome Safari/537.36 Edg"
  },
  {
    "name": "Generic Chrome - Android (No Version)",
    "value": "Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome Mobile Safari/537.36"
  },
  {
    "name": "Generic Safari - iPhone (No Version)",
    "value": "Mozilla/5.0 (iPhone; CPU iPhone OS like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version Mobile Safari/605.1.15"
  }
];


let currentSourceId = null;

function openUserAgentSettings(button) {
    const sourceElement = button.closest('[data-source-id]');
    if (!sourceElement) {
        console.error('openUserAgentSettings: No source element found');
        return;
    }
    
    currentSourceId = sourceElement.dataset.sourceId;
    const source = stateManager.getSource(currentSourceId);
    if (!source) {
        console.error('openUserAgentSettings: Source not found for ID:', currentSourceId);
        return;
    }
    
    // Close the settings menu
    const settingsMenu = button.closest('.settings-menu');
    if (settingsMenu) {
        settingsMenu.classList.remove('active');
    }
    
    // Load saved user agents
    const savedUserAgents = JSON.parse(localStorage.getItem('customUserAgents') || '[]');
    const select = document.getElementById('userAgentSelect');
    
    // Clear existing options
    select.innerHTML = '<option value="AUTO">AUTO (Use config file)</option>';
    
    // Add default user agents
    defaultUserAgents.forEach(ua => {
        const option = document.createElement('option');
        option.value = ua.value;
        option.textContent = ua.name;
        select.appendChild(option);
    });
    
    // Add custom user agents
    savedUserAgents.forEach((ua, index) => {
        const option = document.createElement('option');
        option.value = ua.value;
        option.textContent = `Custom: ${ua.name}`;
        option.dataset.customIndex = index;
        select.appendChild(option);
    });
    
    // Set current selection
    const currentUserAgent = source.userAgent || 'AUTO';
    select.value = currentUserAgent;
    
    // Update custom user agents list
    updateCustomUserAgentsList();
    
    // Show modal
    document.getElementById('userAgentModal').classList.remove('hidden');
}

function closeUserAgentModal() {
    document.getElementById('userAgentModal').classList.add('hidden');
    currentSourceId = null;
}

function addCustomUserAgent() {
    const input = document.getElementById('customUserAgentInput');
    const userAgent = input.value.trim();
    
    if (!userAgent) {
        Toast.error('Input Required', 'Please enter a user agent string');
        return;
    }
    
    // Get saved user agents
    const savedUserAgents = JSON.parse(localStorage.getItem('customUserAgents') || '[]');
    
    // Auto-generate a name based on the user agent string
    let name = 'Custom User Agent';
    if (userAgent.includes('Chrome')) name = 'Custom Chrome';
    else if (userAgent.includes('Firefox')) name = 'Custom Firefox';
    else if (userAgent.includes('Safari') && !userAgent.includes('Chrome')) name = 'Custom Safari';
    else if (userAgent.includes('Edge')) name = 'Custom Edge';
    
    // Add a number if this name already exists
    const existingNames = savedUserAgents.map(ua => ua.name);
    let finalName = name;
    let counter = 1;
    while (existingNames.includes(finalName)) {
        finalName = `${name} ${counter}`;
        counter++;
    }
    
    // Add new user agent
    savedUserAgents.push({ name: finalName, value: userAgent });
    localStorage.setItem('customUserAgents', JSON.stringify(savedUserAgents));
    
    // Clear input
    input.value = '';
    
    // Update the select dropdown immediately
    const select = document.getElementById('userAgentSelect');
    const option = document.createElement('option');
    option.value = userAgent;
    option.textContent = `Custom: ${finalName}`;
    option.dataset.customIndex = savedUserAgents.length - 1;
    select.appendChild(option);
    
    // Update the list display
    updateCustomUserAgentsList();
    
    Toast.success('User Agent Added', `Added "${finalName}" to your custom user agents`);
}

function updateCustomUserAgentsList() {
    const savedUserAgents = JSON.parse(localStorage.getItem('customUserAgents') || '[]');
    const listContainer = document.getElementById('customUserAgentsList');
    
    listContainer.innerHTML = '';
    
    if (savedUserAgents.length === 0) {
        listContainer.innerHTML = '<p style="color: rgba(255,255,255,0.5); font-style: italic;">No custom user agents added yet.</p>';
        return;
    }
    
    savedUserAgents.forEach((ua, index) => {
        const item = document.createElement('div');
        item.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 8px; border-bottom: 1px solid rgba(255,255,255,0.1); margin-bottom: 8px;';
        item.innerHTML = `
            <div style="flex: 1;">
                <strong style="color: #63a4d8;">${ua.name}</strong><br>
                <span style="font-size: 12px; color: rgba(255,255,255,0.7); word-break: break-all;">${ua.value}</span>
            </div>
            <button onclick="removeCustomUserAgent(${index})" style="margin-left: 10px; padding: 4px 8px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">Remove</button>
        `;
        listContainer.appendChild(item);
    });
}

function removeCustomUserAgent(index) {
    if (!confirm('Are you sure you want to remove this custom user agent?')) return;
    
    const savedUserAgents = JSON.parse(localStorage.getItem('customUserAgents') || '[]');
    savedUserAgents.splice(index, 1);
    localStorage.setItem('customUserAgents', JSON.stringify(savedUserAgents));
    
}

function saveUserAgentSelection() {
    if (!currentSourceId) {
        console.error('No source ID set');
        return;
    }
    
    const select = document.getElementById('userAgentSelect');
    const selectedValue = select.value;
    
    // Update the source
    const source = stateManager.getSource(currentSourceId);
    if (!source) {
        console.error('Source not found:', currentSourceId);
        return;
    }
    
    // Save the user agent preference
    source.userAgent = selectedValue;
    stateManager.updateSource(currentSourceId, { userAgent: selectedValue });
    
    // Show success message
    Toast.success('User Agent Updated', `User agent preference saved for ${source.username || source.target}`);
    
    // Close modal
    closeUserAgentModal();
}

// User agent handling is now done directly in the window creation functions

// Session Management Functions
let currentSessionSourceId = null;

function openSessionSettings(button) {
    const sourceElement = button.closest('[data-source-id]');
    if (!sourceElement) {
        console.error('openSessionSettings: No source element found');
        return;
    }
    
    currentSessionSourceId = sourceElement.dataset.sourceId;
    const source = stateManager.getSource(currentSessionSourceId);
    if (!source) {
        console.error('openSessionSettings: Source not found:', currentSessionSourceId);
        return;
    }
    
    // Close settings menu
    const settingsMenu = button.closest('.settings-menu');
    if (settingsMenu) {
        settingsMenu.classList.remove('active');
    }
    
    // Store the current session value
    // If no custom session or AUTO, default to platform default
    if (!source.customSession || source.customSession === 'AUTO') {
        window.currentSelectedSession = `default-${source.target}`;
    } else {
        window.currentSelectedSession = source.customSession;
    }
    
    // Update sessions list
    updateSessionsList();
    
    // Show modal
    document.getElementById('sessionModal').classList.remove('hidden');
}

function closeSessionModal() {
    document.getElementById('sessionModal').classList.add('hidden');
    currentSessionSourceId = null;
}

function addCustomSession() {
    const input = document.getElementById('customSessionName');
    const sessionName = input.value.trim();
    
    if (!sessionName) {
        Toast.error('Input Required', 'Please enter a session name');
        return;
    }
    
    // Validate session name (alphanumeric, hyphens, underscores only)
    if (!/^[a-zA-Z0-9-_]+$/.test(sessionName)) {
        Toast.error('Invalid Name', 'Session names can only contain letters, numbers, hyphens, and underscores');
        return;
    }
    
    // Get saved sessions
    const customSessions = JSON.parse(localStorage.getItem('customSessions') || '[]');
    
    // Check if name already exists
    if (customSessions.some(s => s.name === sessionName)) {
        Toast.error('Name Exists', 'A session with this name already exists');
        return;
    }
    
    // Add new session
    customSessions.push({
        name: sessionName,
        created: Date.now(),
        description: `Custom session for ${sessionName}`
    });
    
    localStorage.setItem('customSessions', JSON.stringify(customSessions));
    
    // Clear input
    input.value = '';
    
    // Auto-select the newly created session
    window.currentSelectedSession = sessionName;
    
    // Update the list display immediately
    updateSessionsList();
    
    Toast.success('Session Created', `Created custom session "${sessionName}" and selected it`);
}

function updateSessionsList() {
    const container = document.getElementById('sessionsList');
    if (!container) return;
    
    // Clear container
    container.innerHTML = '';
    
    // Get current source info
    const source = stateManager.getSource(currentSessionSourceId);
    if (!source) return;
    
    // Platform defaults
    const platformDefaults = {
        'youtube': 'YouTube Default',
        'youtubeshorts': 'YouTube Default',
        'twitch': 'Twitch Default',
        'kick': 'Kick Default',
        'tiktok': 'TikTok Default',
        'facebook': 'Facebook Default',
        'instagramlive': 'Instagram Default',
        'x': 'X.com Default',
        'rumble': 'Rumble Default'
    };
    
    // Add platform-specific default if available
    if (platformDefaults[source.target]) {
        const platformDiv = document.createElement('div');
        platformDiv.className = 'session-item';
        platformDiv.dataset.sessionValue = `default-${source.target}`;
        if (window.currentSelectedSession === `default-${source.target}`) {
            platformDiv.classList.add('selected');
        }
        platformDiv.innerHTML = `
            <span class="session-item-name">${platformDefaults[source.target]}</span>
            <span class="session-item-actions">
                <span style="color: #aaa; font-size: 12px;">Platform default</span>
            </span>
        `;
        platformDiv.onclick = () => selectSession(`default-${source.target}`);
        container.appendChild(platformDiv);
    }
    
    // Add custom sessions
    const customSessions = JSON.parse(localStorage.getItem('customSessions') || '[]');
    customSessions.forEach(session => {
        const sessionDiv = document.createElement('div');
        sessionDiv.className = 'session-item';
        sessionDiv.dataset.sessionValue = session.name;
        if (window.currentSelectedSession === session.name) {
            sessionDiv.classList.add('selected');
        }
        sessionDiv.innerHTML = `
            <span class="session-item-name">${session.name}</span>
            <span class="session-item-actions">
                <span style="color: #aaa; font-size: 12px;">Custom</span>
                <button class="session-remove-btn" onclick="event.stopPropagation(); removeCustomSession('${session.name}')" title="Remove session">×</button>
            </span>
        `;
        sessionDiv.onclick = () => selectSession(session.name);
        container.appendChild(sessionDiv);
    });
}

function selectSession(sessionValue) {
    console.log(`[SESSION DEBUG] Selected session: ${sessionValue}`);
    window.currentSelectedSession = sessionValue;
    
    // Update visual selection
    document.querySelectorAll('.session-item').forEach(item => {
        item.classList.remove('selected');
        if (item.dataset.sessionValue === sessionValue) {
            item.classList.add('selected');
        }
    });
}

function removeCustomSession(sessionName) {
    if (!confirm('Are you sure you want to remove this custom session? Any sources using this session will revert to default.')) return;
    
    const customSessions = JSON.parse(localStorage.getItem('customSessions') || '[]');
    const sessionIndex = customSessions.findIndex(s => s.name === sessionName);
    
    if (sessionIndex === -1) return;
    
    customSessions.splice(sessionIndex, 1);
    localStorage.setItem('customSessions', JSON.stringify(customSessions));
    
    // Update any sources using this session
    const allSources = stateManager.getSources();
    allSources.forEach(source => {
        if (source.customSession === sessionName) {
            stateManager.updateSource(source.id, { customSession: 'default' });
        }
    });
    
    // If this was the selected session, select platform default
    if (window.currentSelectedSession === sessionName) {
        const source = stateManager.getSource(currentSessionSourceId);
        window.currentSelectedSession = source ? `default-${source.target}` : 'AUTO';
    }
    
    // Update the list
    updateSessionsList();
    
    Toast.success('Session Removed', `Removed session "${sessionName}"`);
}

function saveSessionSelection() {
    if (!currentSessionSourceId) {
        console.error('No source ID set');
        return;
    }
    
    // Update the source
    const source = stateManager.getSource(currentSessionSourceId);
    if (!source) {
        console.error('Source not found:', currentSessionSourceId);
        return;
    }
    
    // Save the session preference
    console.log(`[SESSION DEBUG] Saving customSession: ${window.currentSelectedSession} for source: ${currentSessionSourceId}`);
    stateManager.updateSource(currentSessionSourceId, { customSession: window.currentSelectedSession });
    
    // Verify it was saved
    const updatedSource = stateManager.getSource(currentSessionSourceId);
    console.log(`[SESSION DEBUG] Source after update:`, updatedSource.customSession);
    
    // Show success message
    const sessionName = window.currentSelectedSession === 'AUTO' ? 'default' : window.currentSelectedSession;
    Toast.success('Session Updated', `Session preference set to "${sessionName}" for ${source.username || source.target}`);
    
    // Close modal
    closeSessionModal();
}

</script>
</body>
</html>
